<!DOCTYPE html>
<html lang="en"><head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Wind Turbine 3D</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
        }
        #controls-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 0;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            max-width: 350px;
            max-height: 90vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        #controls-panel .panel-header {
            padding: 20px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 12px 12px 0 0;
            flex-shrink: 0;
        }
        #controls-panel #controls-content {
            padding: 0 20px 20px 20px;
            overflow-y: auto;
            flex: 1;
        }
        #controls-panel.minimized {
            max-height: none;
            height: auto !important;
        }
        #controls-panel.minimized #controls-content {
            display: none;
        }
        #controls-panel.minimized .panel-header {
            padding-bottom: 20px;
        }
        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #667eea;
        }
        h2 {
            color: #333;
            font-size: 1.5em;
            margin: 0;
        }
        .minimize-btn {
            background: #667eea;
            color: white;
            border: none;
            border-radius: 4px;
            width: 30px;
            height: 30px;
            cursor: pointer;
            font-size: 1.2em;
            line-height: 1;
        }
        .minimize-btn:hover {
            background: #5568d3;
        }
        .control-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            color: #555;
            font-weight: 500;
        }
        input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }
        .value-display {
            display: inline-block;
            min-width: 50px;
            text-align: right;
            font-weight: bold;
            color: #667eea;
        }
        .info-text {
            font-size: 0.85em;
            color: #777;
            margin-top: 3px;
        }
        #stats {
            position: absolute;
            top: 20px;
            left: calc(100vw - 240px);
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            min-width: 200px;
        }
        #stats h3 {
            margin-bottom: 10px;
            color: #333;
            font-size: 1.2em;
        }
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px solid #eee;
        }
        .stat-row:last-child {
            border-bottom: none;
        }
        .stat-label {
            color: #666;
        }
        .stat-value {
            font-weight: bold;
            color: #667eea;
        }
        #legend {
            position: absolute;
            top: calc(100vh - 220px);
            left: calc(100vw - 240px);
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        #legend h3 {
            margin-bottom: 10px;
            color: #333;
            font-size: 1.1em;
        }
        .legend-gradient {
            height: 30px;
            background: linear-gradient(to right, 
                #0000ff, #0080ff, #00ffff, #00ff00, 
                #ffff00, #ff8000, #ff0000, #8b0000);
            border-radius: 5px;
            margin-bottom: 8px;
        }
        .legend-labels {
            display: flex;
            justify-content: space-between;
            font-size: 0.85em;
            color: #666;
        }
        #plot-panel {
            position: absolute;
            top: calc(100vh - 640px);
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 0;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            max-width: 90vw;
            max-height: 90vh;
            width: 800px;
            height: 600px;
            resize: both;
            overflow: scroll;
            display: flex;
            flex-direction: column;
        }
        #plot-panel .plot-header {
            padding: 15px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 12px 12px 0 0;
            cursor: move;
            user-select: none;
            flex-shrink: 0;
        }
        #plot-panel #plot-content {
            padding: 15px;
            overflow: auto;
            flex: 1;
            min-height: 0;
        }
        #total-loads-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 0;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            width: 600px;
            height: 500px;
            z-index: 100;
            resize: both;
            overflow: scroll;
            display: flex;
            flex-direction: column;
        }
        #total-loads-panel .plot-header {
            padding: 15px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 12px 12px 0 0;
            cursor: move;
            user-select: none;
            flex-shrink: 0;
        }
        #total-loads-panel.minimized {
            height: auto !important;
            resize: none;
            width: auto !important;
            overflow: hidden !important;
        }
        #total-loads-panel.minimized #total-loads-content {
            display: none;
        }
        #total-loads-panel.minimized .plot-header {
            margin-bottom: 0;
            padding-bottom: 15px;
            border-bottom: none;
        }
        #total-loads-panel #total-loads-content {
            padding: 15px;
            overflow: auto;
            flex: 1;
            min-height: 0;
        }
        #spanwise-panel {
            position: absolute;
            top: 120px;
            left: calc(100vw - 620px);
            background: rgba(255, 255, 255, 0.95);
            padding: 0;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            max-width: 90vw;
            max-height: 90vh;
            width: 600px;
            height: 700px;
            resize: both;
            overflow: scroll;
            display: flex;
            flex-direction: column;
        }
        #spanwise-panel .plot-header {
            padding: 15px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 12px 12px 0 0;
            cursor: move;
            user-select: none;
            flex-shrink: 0;
        }
        #spanwise-panel.minimized {
            width: auto !important;
            height: auto !important;
            max-width: none !important;
            max-height: none !important;
            resize: none;
            overflow: hidden !important;
        }
        #spanwise-panel.minimized #spanwise-content {
            display: none;
            height: 0 !important;
            overflow: hidden !important;
        }
        #spanwise-panel.minimized .plot-header {
            margin-bottom: 0;
            padding-bottom: 15px;
            border-bottom: none;
        }
        #spanwise-panel #spanwise-content {
            padding: 15px;
            overflow: auto;
            flex: 1;
            min-height: 0;
        }
        #plot-panel.minimized {
            width: auto !important;
            height: auto !important;
            max-width: none !important;
            max-height: none !important;
            resize: none;
            overflow: hidden !important;
        }
        #plot-panel.minimized #plot-content {
            display: none;
            height: 0 !important;
            overflow: hidden !important;
        }
        #plot-panel.minimized .trace-tab-content {
            height: 0 !important;
        }
        #plot-panel.minimized .plot-header {
            margin-bottom: 0;
            padding-bottom: 15px;
            border-bottom: none;
        }
        .plot-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #667eea;
        }
        .plot-title {
            color: #333;
            font-size: 1.2em;
            font-weight: bold;
        }
        .plot-controls {
            margin-bottom: 15px;
        }
        .trace-tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
            border-bottom: 2px solid #ddd;
        }
        .trace-tab-btn {
            padding: 8px 16px;
            background: none;
            border: none;
            border-bottom: 3px solid transparent;
            cursor: pointer;
            font-size: 0.95em;
            color: #666;
            transition: all 0.2s;
        }
        .trace-tab-btn:hover {
            color: #333;
            background: rgba(102, 126, 234, 0.1);
        }
        .trace-tab-btn.active {
            color: #667eea;
            border-bottom-color: #667eea;
            font-weight: bold;
        }
        .trace-tab-content {
            display: none;
            height: calc(100% - 120px);
            overflow-y: auto;
        }
        .trace-tab-content.active {
            display: block;
        }
        .spanwise-tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
            border-bottom: 2px solid #ddd;
        }
        .spanwise-tab-btn {
            padding: 8px 16px;
            background: none;
            border: none;
            border-bottom: 3px solid transparent;
            cursor: pointer;
            font-size: 0.95em;
            color: #666;
            transition: all 0.2s;
        }
        .spanwise-tab-btn:hover {
            color: #333;
            background: rgba(102, 126, 234, 0.1);
        }
        .spanwise-tab-btn.active {
            color: #667eea;
            border-bottom-color: #667eea;
            font-weight: bold;
        }
        .spanwise-tab-content {
            display: none;
        }
        .spanwise-tab-content.active {
            display: block;
        }
        .chart-container {
            margin-bottom: 20px;
            height: 300px;
        }
        .chart-with-fourier {
            display: flex;
            flex-direction: column;
            gap: 15px;
            height: 100%;
        }
        .chart-with-fourier .chart-container {
            flex: 1;
            min-height: 250px;
        }
        .fourier-summary {
            background: #f9f9f9;
            padding: 15px;
            border-radius: 8px;
            max-height: 300px;
            overflow-y: auto;
        }
        input[type="checkbox"] {
            margin-right: 5px;
        }
        select {
            width: 100%;
            padding: 5px;
            border-radius: 4px;
            border: 1px solid #ddd;
        }
        #display-toggle {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 12px 24px;
            background: rgba(102, 126, 234, 0.95);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            cursor: pointer;
            box-shadow: 0 4px 16px rgba(0,0,0,0.3);
            z-index: 10000;
            transition: all 0.3s;
        }
        #display-toggle:hover {
            background: rgba(102, 126, 234, 1);
            transform: scale(1.05);
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <!-- Twist Settings Modal -->
    <div id="twist-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 10000; justify-content: center; align-items: center;">
        <div style="background: white; padding: 30px; border-radius: 10px; max-width: 500px; width: 90%;">
            <h3 style="margin-top: 0; color: #667eea;">Blade Twist Distribution</h3>
            <p style="font-size: 0.9em; color: #666; margin-bottom: 20px;">
                Define the twist angle from blade root to tip. Typical wind turbines have higher twist at the root for better performance at low speeds.
            </p>
            
            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 5px; font-weight: 500;">Root Twist: <span id="twist-root-display">14</span>¬∞</label>
                <input type="range" id="twist-root" min="-20" max="45" value="14" step="0.5" style="width: 100%;">
                <div style="font-size: 0.85em; color: #888; margin-top: 3px;">Twist angle at blade root (hub)</div>
            </div>
            
            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 5px; font-weight: 500;">Tip Twist: <span id="twist-tip-display">0</span>¬∞</label>
                <input type="range" id="twist-tip" min="-20" max="45" value="0" step="0.5" style="width: 100%;">
                <div style="font-size: 0.85em; color: #888; margin-top: 3px;">Twist angle at blade tip</div>
            </div>
            
            <div style="background: #f5f5f5; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                <div style="font-size: 0.9em; font-weight: 500; margin-bottom: 5px;">Common Presets:</div>
                <button class="twist-preset" data-root="14" data-tip="0" style="margin: 3px; padding: 5px 10px; background: #667eea; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.85em;">Standard (14¬∞-0¬∞)</button>
                <button class="twist-preset" data-root="20" data-tip="0" style="margin: 3px; padding: 5px 10px; background: #667eea; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.85em;">High Twist (20¬∞-0¬∞)</button>
                <button class="twist-preset" data-root="10" data-tip="-5" style="margin: 3px; padding: 5px 10px; background: #667eea; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.85em;">Low Twist (10¬∞-(-5)¬∞)</button>
                <button class="twist-preset" data-root="0" data-tip="0" style="margin: 3px; padding: 5px 10px; background: #667eea; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.85em;">No Twist (0¬∞-0¬∞)</button>
            </div>
            
            <div style="display: flex; justify-content: flex-end; gap: 10px;">
                <button id="twist-close-btn" style="padding: 8px 20px; background: #ccc; color: #333; border: none; border-radius: 4px; cursor: pointer; font-size: 0.9em;">Close</button>
            </div>
        </div>
    </div>
    
    <div id="controls-panel">
        <div class="panel-header">
            <h2>üå¨Ô∏è Wind Turbine Controls</h2>
            <button class="minimize-btn" id="minimize-btn">+</button>
        </div>
        <div id="controls-content">
            <div class="control-group">
                <label>Wind Speed: <span class="value-display" id="wind-speed-value">7.0</span> m/s</label>
                <input type="range" id="wind-speed" min="0" max="25" value="7" step="0.5">
            </div>
            
            <div class="control-group">
                <label>Shaft Speed: <span class="value-display" id="shaft-speed-value">15.0</span> RPM</label>
                <input type="range" id="shaft-speed" min="0" max="20" value="15" step="0.5">
                <label style="font-size: 0.9em; margin-top: 5px;">
                    <input type="checkbox" id="dynamic-speed"> Dynamic Speed (Physics-Based)
                </label>
            </div>
            
            <div class="control-group" id="dynamic-speed-params" style="display: none; margin-left: 15px; border-left: 2px solid #667eea; padding-left: 10px;">
                <label style="font-size: 0.9em;">Generator Torque: <span class="value-display" id="gen-torque-value">50000</span> N‚ãÖm</label>
                <input type="range" id="generator-torque" min="10000" max="100000" value="50000" step="1000">
                <label style="font-size: 0.9em;">Rotor Inertia: <span class="value-display" id="rotor-inertia-value">1000000</span> kg‚ãÖm¬≤</label>
                <input type="range" id="rotor-inertia" min="0" max="5000000" value="1000000" step="50000">
            </div>
            
            <div class="control-group">
                <label>
                    <input type="checkbox" id="pause-rotation"> Pause Rotation
                </label>
            </div>
            
            <div class="control-group">
                <label>Manual Rotation: <span class="value-display" id="manual-rotation-value">0.0</span>¬∞</label>
                <input type="range" id="manual-rotation" min="0" max="360" value="0" step="0.1">
                <div class="info-text">Manual rotor angle control (when paused)</div>
            </div>
            
            <div class="control-group">
                <label>Blade Pitch: <span class="value-display" id="blade-pitch-value">5.0</span>¬∞</label>
                <input type="range" id="blade-pitch" min="-10" max="90" value="5" step="1">
                <div class="info-text">0¬∞ = in disc plane, 90¬∞ = fully feathered</div>
                <button id="twist-settings-btn" style="margin-top: 5px; padding: 5px 10px; background: #667eea; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.9em;">‚öôÔ∏è Twist Settings</button>
            </div>
            
            <div class="control-group">
                <label>Number of Blades: <span class="value-display" id="num-blades-value">3</span></label>
                <input type="range" id="num-blades" min="1" max="20" value="3" step="1">
            </div>
            
            <div class="control-group">
                <label>Wind Direction: <span class="value-display" id="yaw-value">0.0</span>¬∞</label>
                <input type="range" id="yaw" min="-180" max="180" value="0" step="5">
                <div class="info-text">Wind yaw angle (turbine stays fixed)</div>
            </div>
            
            <div class="control-group">
                <label>Inflow Angle: <span class="value-display" id="inflow-value">0.0</span>¬∞</label>
                <input type="range" id="inflow" min="-20" max="20" value="0" step="1">
                <div class="info-text">Vertical wind component</div>
            </div>
            
            <div class="control-group">
                <label>
                    <input type="checkbox" id="show-axes"> Show Axes (RGB = XYZ)
                </label>
                <div class="info-text">Red=X, Green=Y, Blue=Z</div>
            </div>
            
            
            <div class="control-group">
                <label>
                    <input type="checkbox" id="wind-farm-mode"> Wind Farm Mode (5 Turbines)
                </label>
                <div class="info-text">Multiple turbines with speed variation</div>
            </div>
            
            <div class="control-group">
                <label>
                    <input type="checkbox" id="show-heatmap" checked=""> Show Load Heatmap
                </label>
                <div class="info-text">Color-coded blade loads</div>
            </div>
            
            <div class="control-group">
                <label>
                    <input type="checkbox" id="debug-camber"> üêõ Debug: Super Extra Camber
                </label>
                <div class="info-text">Exaggerate camber to verify blade orientation</div>
            </div>
            
            <div class="control-group">
                <label>
                    <input type="checkbox" id="simple-aero"> Simple Aerodynamics
                </label>
                <div class="info-text">Linear lift model: CL = 0.05 + 5.7*AoA, CD = 0.1*CL</div>
            </div>
            
            <div class="control-group">
                <label>
                    <input type="checkbox" id="show-wind-vector" checked> Show Wind Vector
                </label>
                <div class="info-text">Display incoming wind direction arrow</div>
            </div>
            
            <div class="control-group">
                <label>
                    <input type="checkbox" id="remove-mean"> Remove 0P (Mean Component)
                </label>
                <div class="info-text">Show only alternating loads</div>
            </div>
            
            <div class="control-group">
                <label>
                    <input type="checkbox" id="debug-sinusoid"> üîç Debug: Pure Sinusoid Loads
                </label>
                <div class="info-text">Replace blade loads with sin(œà) for testing</div>
            </div>
            
            <div class="control-group">
                <label>
                    <input type="checkbox" id="show-vectors"> Show Force Vectors
                </label>
            </div>
            
            <div class="control-group">
                <label>Vector Scale: <span class="value-display" id="vector-scale-value">0.100</span></label>
                <input type="range" id="vector-scale" min="0.001" max="1.0" value="0.1" step="0.001">
            </div>
            
            <div class="control-group">
                <label>Load Annotations:</label>
                <select id="vector-mode">
                    <option value="all">All Blades</option>
                    <option value="single">Single Blade</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>Angular Resolution: <span class="value-display" id="angular-res-value">1.0</span>¬∞</label>
                <input type="range" id="angular-resolution" min="0.333" max="15" value="1" step="0.01">
                <div class="info-text">Sampling resolution (lower = more detail)</div>
            </div>
            
            <div class="control-group">
                <label>3D Model Opacity: <span class="value-display" id="model-opacity-value">1.0</span></label>
                <input type="range" id="model-opacity" min="0.0" max="1.0" value="1.0" step="0.05">
                <div class="info-text">Opacity of turbine model (section plane unaffected)</div>
            </div>
        </div>
    </div>
    
    <div id="spanwise-panel">
        <div class="plot-header">
            <div class="plot-title">üìê Spanwise Analysis</div>
            <button class="minimize-btn" id="minimize-spanwise-btn">‚àí</button>
        </div>
        <div id="spanwise-content">
            <div class="spanwise-tabs">
                <button class="spanwise-tab-btn active" data-tab="loading">Spanwise Loading</button>
                <button class="spanwise-tab-btn" data-tab="section">Section Analysis</button>
            </div>
            
            <div id="loading-tab" class="spanwise-tab-content active">
                <div style="padding: 10px; height: 100%;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <p style="font-size: 0.9em; margin: 0;">Loading distribution along blade span</p>
                        <select id="spanwise-force-type" style="padding: 3px 8px; font-size: 0.9em;">
                            <option value="thrust">Thrust</option>
                            <option value="tangential">Tangential Force</option>
                            <option value="resultant">Resultant Force</option>
                            <option value="aoa">Angle of Attack (AoA)</option>
                            <option value="velocity">Total Velocity</option>
                            <option value="cl">Lift Coefficient (CL)</option>
                            <option value="cd">Drag Coefficient (CD)</option>
                        </select>
                    </div>
                    <div style="height: 450px;">
                    <canvas id="spanwise-chart"></canvas>
                    </div>
                </div>
            </div>
            
            <div id="section-tab" class="spanwise-tab-content">
                <div style="padding: 10px;">
                    <p style="font-size: 0.9em; margin: 5px 0 10px 0;">
                        Airfoil section with velocity vectors
                        <button id="reset-zoom-btn" style="margin-left: 10px; padding: 2px 8px; font-size: 0.85em;">Reset View</button>
                        <label style="margin-left: 15px; font-size: 0.85em;">
                            <input type="checkbox" id="reverse-x-axis"> Reverse X
                        </label>
                        <label style="margin-left: 10px; font-size: 0.85em;">
                            <input type="checkbox" id="reverse-y-axis"> Reverse Y
                        </label>
                        <label style="margin-left: 15px; font-size: 0.85em;">
                            <input type="checkbox" id="show-section-plane"> Show Plane
                        </label>
                    </p>
                    <p style="font-size: 0.85em; margin: 5px 0; font-family: monospace; background: #f0f0f0; padding: 5px 8px; border-radius: 3px;">
                        Blade Angle = <span id="pitch-display">0.00</span>¬∞ | œÜ = <span id="phi-display">0.00</span>¬∞ | AoA = <span id="aoa-display">0.00</span>¬∞ | CL = <span id="cl-display">0.00</span> | CD = <span id="cd-display">0.00</span>
                    </p>
                    <div style="margin-bottom: 10px;">
                        <label style="font-size: 0.9em;">Radial Station (% span): <span class="value-display" id="section-station-value">50</span></label>
                        <input type="range" id="section-radial-station" min="10" max="95" value="50" step="5" style="width: 100%;">
                    </div>
                    <div style="margin-bottom: 10px;">
                        <label style="font-size: 0.9em;">Force Scale: <span class="value-display" id="force-scale-value">1.0</span>x</label>
                        <input type="range" id="force-scale" min="0.1" max="100.0" value="1.0" step="0.1" style="width: 100%;">
                    </div>
                    <div style="height: 400px;">
                    <canvas id="section-chart"></canvas>
                    </div>
                </div>
            </div>
            
            <!-- Blade Position Display -->
            <div style="background: #f0f0f0; padding: 10px; margin: 10px; border-radius: 5px; font-family: monospace; text-align: center;">
                <strong>Blade 1 Position (œà):</strong> <span id="blade-azimuth-display" style="color: #667eea; font-weight: bold;">0.0¬∞</span>
            </div>
        </div>
    </div>
    
    <div id="plot-panel">
        <div class="plot-header">
            <div class="plot-title">üìä Load Traces</div>
            <button class="minimize-btn" id="minimize-plot-btn">+</button>
        </div>
        <div id="plot-content">
            <div class="plot-controls">
                <label>Radial Station (% span): <span class="value-display" id="station-value">50</span></label>
                <input type="range" id="radial-station" min="10" max="95" value="50" step="5">
            </div>
            
            <div class="trace-tabs">
                <button class="trace-tab-btn active" data-tab="thrust">Thrust</button>
                <button class="trace-tab-btn" data-tab="moment-y">Yawing Moment</button>
                <button class="trace-tab-btn" data-tab="moment-z">Nodding Moment</button>
                <button class="trace-tab-btn" data-tab="aoa">Angle of Attack</button>
                <button class="trace-tab-btn" data-tab="velocity">Total Velocity</button>
                <button class="trace-tab-btn" data-tab="lift">Lift</button>
                <button class="trace-tab-btn" data-tab="debug">Debug</button>
            </div>
            
            <div id="thrust-tab" class="trace-tab-content active">
                <div class="chart-with-fourier">
                    <div class="chart-container">
                        <canvas id="lift-chart"></canvas>
                    </div>
                    <div class="fourier-summary">
                        <h4 style="margin-top: 0; font-size: 1em;">Thrust Harmonics</h4>
                        <div id="fourier-thrust-content"></div>
                    </div>
                </div>
            </div>
            
            <div id="moment-y-tab" class="trace-tab-content">
                <div class="chart-with-fourier">
                    <div class="chart-container">
                        <canvas id="moment-y-chart"></canvas>
                    </div>
                    <div class="fourier-summary">
                        <h4 style="margin-top: 0; font-size: 1em;">Yawing Moment Harmonics</h4>
                        <div id="fourier-moment-y-content"></div>
                    </div>
                </div>
            </div>
            
            <div id="moment-z-tab" class="trace-tab-content">
                <div class="chart-with-fourier">
                    <div class="chart-container">
                        <canvas id="moment-z-chart"></canvas>
                    </div>
                    <div class="fourier-summary">
                        <h4 style="margin-top: 0; font-size: 1em;">Nodding Moment Harmonics</h4>
                        <div id="fourier-moment-z-content"></div>
                    </div>
                </div>
            </div>
            
            <div id="aoa-tab" class="trace-tab-content">
                <div class="chart-with-fourier">
                    <div class="chart-container">
                        <canvas id="aoa-chart"></canvas>
                    </div>
                    <div class="fourier-summary">
                        <h4 style="margin-top: 0; font-size: 1em;">Angle of Attack Harmonics</h4>
                        <div id="fourier-aoa-content"></div>
                    </div>
                </div>
            </div>
            
            <div id="velocity-tab" class="trace-tab-content">
                <div class="chart-with-fourier">
                    <div class="chart-container">
                        <canvas id="velocity-chart"></canvas>
                    </div>
                    <div class="fourier-summary">
                        <h4 style="margin-top: 0; font-size: 1em;">Total Velocity Harmonics</h4>
                        <div id="fourier-velocity-content"></div>
                    </div>
                </div>
            </div>
            
            <div id="lift-tab" class="trace-tab-content">
                <div class="chart-with-fourier">
                    <div class="chart-container">
                        <canvas id="lift-force-chart"></canvas>
                    </div>
                    <div class="fourier-summary">
                        <h4 style="margin-top: 0; font-size: 1em;">Lift Harmonics</h4>
                        <div id="fourier-lift-content"></div>
                    </div>
                </div>
            </div>
            
            <div id="debug-tab" class="trace-tab-content">
                <button id="generate-debug" style="margin-bottom: 10px; padding: 8px 16px; background: #667eea; color: white; border: none; border-radius: 4px; cursor: pointer;">Generate Debug Data (2 Blades, 2 Revolutions)</button>
                <div id="debug-output" style="font-family: monospace; font-size: 0.85em;"></div>
            </div>
        </div>
    </div>

    <button id="display-toggle">üì∫ Hide Displays</button>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@1.2.1/dist/chartjs-plugin-zoom.min.js"></script>
    
    <!-- Total Inertially-Fixed Loads Panel -->
    <div id="total-loads-panel" style="display: none;">
        <div class="plot-header">
            <div class="plot-title">üìä Total Load</div>
            <button class="minimize-btn" id="minimize-total-loads-btn">‚àí</button>
        </div>
        <div id="total-loads-content">
            <div class="trace-tabs">
                <button class="trace-tab-btn active" data-tab="total-thrust">Thrust</button>
                <button class="trace-tab-btn" data-tab="total-torque">Torque</button>
                <button class="trace-tab-btn" data-tab="total-nodding-moment">Nodding Moment</button>
                <button class="trace-tab-btn" data-tab="total-yawing-moment">Yawing Moment</button>
            </div>
            
            <div id="total-thrust-tab" class="trace-tab-content active">
                <h4 style="margin: 10px 0; font-size: 0.95em;">Thrust - Rotating Reference Frame</h4>
                <div class="chart-container" style="height: 250px;">
                    <canvas id="thrust-rotating-chart"></canvas>
                </div>
                <h4 style="margin: 10px 0; font-size: 0.95em;">Thrust - Inertially-Fixed Reference Frame</h4>
                <div class="chart-with-fourier">
                    <div class="chart-container" style="height: 250px;">
                        <canvas id="thrust-fixed-chart"></canvas>
                    </div>
                    <div class="fourier-summary">
                        <h4 style="margin-top: 0; font-size: 1em;">Total Thrust Harmonics</h4>
                        <div id="fourier-total-thrust-content"></div>
                    </div>
                </div>
            </div>
            
            <div id="total-torque-tab" class="trace-tab-content">
                <h4 style="margin: 10px 0; font-size: 0.95em;">Torque - Rotating Reference Frame</h4>
                <div class="chart-container" style="height: 250px;">
                    <canvas id="torque-rotating-chart"></canvas>
                </div>
                <h4 style="margin: 10px 0; font-size: 0.95em;">Torque - Inertially-Fixed Reference Frame</h4>
                <div class="chart-with-fourier">
                    <div class="chart-container" style="height: 250px;">
                        <canvas id="torque-fixed-chart"></canvas>
                    </div>
                    <div class="fourier-summary">
                        <h4 style="margin-top: 0; font-size: 1em;">Total Torque Harmonics</h4>
                        <div id="fourier-total-torque-content"></div>
                    </div>
                </div>
            </div>
            
            <div id="total-nodding-moment-tab" class="trace-tab-content">
                <h4 style="margin: 10px 0; font-size: 0.95em;">Nodding Moment - Inertially-Fixed Reference Frame</h4>
                <div class="chart-with-fourier">
                    <div class="chart-container" style="height: 350px;">
                        <canvas id="nodding-moment-chart"></canvas>
                    </div>
                    <div class="fourier-summary">
                        <h4 style="margin-top: 0; font-size: 1em;">Nodding Moment Harmonics</h4>
                        <div id="fourier-nodding-moment-content"></div>
                    </div>
                </div>
            </div>
            
            <div id="total-yawing-moment-tab" class="trace-tab-content">
                <h4 style="margin: 10px 0; font-size: 0.95em;">Yawing Moment - Inertially-Fixed Reference Frame</h4>
                <div class="chart-with-fourier">
                    <div class="chart-container" style="height: 350px;">
                        <canvas id="yawing-moment-chart"></canvas>
                    </div>
                    <div class="fourier-summary">
                        <h4 style="margin-top: 0; font-size: 1em;">Yawing Moment Harmonics</h4>
                        <div id="fourier-yawing-moment-content"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Photo Rendering Mode Dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/RGBELoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/pmrem/PMREMGenerator.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/BokehPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/FXAAShader.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);
        scene.fog = null; // No fog in default mode
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(50, 30, 50);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; // ready for photo mode
        document.getElementById('canvas-container').appendChild(renderer.domElement);
        
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(50, 50, 50);
        directionalLight.castShadow = true;
        
        // Configure shadow camera for proper coverage
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.left = -100;
        directionalLight.shadow.camera.right = 100;
        directionalLight.shadow.camera.top = 100;
        directionalLight.shadow.camera.bottom = -100;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 200;
        directionalLight.shadow.bias = -0.0001;
        
        scene.add(directionalLight);
        
        // Debug axes
        const sceneAxes = new THREE.AxesHelper(30);
        sceneAxes.visible = false;
        scene.add(sceneAxes);
        
        const rotorAxes = new THREE.AxesHelper(25);
        rotorAxes.visible = false;
        
        const nacelleAxes = new THREE.AxesHelper(5);
        nacelleAxes.visible = false;
        
        // --- Photo mode config/state ---
        const PhotoConfig = {
            HDRI_URL: "https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/2k/kloppenheim_06_2k.hdr",
            bloomStrength: 0.35,
            bloomRadius: 0.8,
            bloomThreshold: 0.85,
            bokehFocusNear: 15,
            bokehFocusFar: 80,
            bokehAperture: 0.00001,   // Minimal blur
            bokehMaxBlur: 0.0005,     // Almost no blur
            useBokeh: false,          // Disable bokeh by default
        };
        
        let isPhotoMode = false;
        let composer = null, renderPass = null, bloomPass = null, bokehPass = null, fxaaPass = null;
        let pmremGen = null, envMap = null;
        let skyboxMesh = null;  // For scalable background
        let cloudPlane = null;  // Animated cloud layer
        let cloudOffset = 0;    // For scrolling clouds
        let ground = null;      // Ground plane
        
        // remember "simple" look to restore
        const OriginalLook = {
            background: scene.background ? scene.background.clone() : null,
            fog: scene.fog || null,
            dirLightIntensity: directionalLight.intensity,
        };
        
        // cache original materials to restore later
        const OriginalMats = new Map(); // mesh => material
        function cacheMaterial(mesh){
            if (!OriginalMats.has(mesh)) OriginalMats.set(mesh, mesh.material);
        }
        
        // Animation frame counter
        let frameCount = 0;
        
        // Turbine parameters
        const turbineParams = {
            windSpeed: 7,      // Reduced from 10 to 7 m/s for better initial TSR
            shaftSpeed: 15,    // Increased from 10 to 15 RPM to avoid stall deadlock
            bladePitch: 5,     // Added 5¬∞ pitch to improve initial AoA
            bladeTwist: 15, // Total twist from root to tip in degrees (DEPRECATED - use twist params below)
            twistRoot: 14,  // Twist angle at blade root (degrees)
            twistTip: 0,    // Twist angle at blade tip (degrees)
            numBlades: 3,
            yawAngle: 0,
            inflowAngle: 0,
            towerHeight: 30,
            bladeRadius: 20,
            hubRadius: 1.5,
            radialStation: 0.5,  // 0 to 1 (fraction of span)
            showVectors: false,  // Show force vectors
            vectorScale: 0.1,    // Force vector scale factor
            vectorMode: 'all',   // 'all' or 'single' blade
            showHeatmap: true,   // Show load heatmap on blades
            debugCamber: false,  // Debug mode: super extra camber
            showWindVector: true, // Show wind vector arrow
            simpleAero: false,   // Simple aerodynamics mode (linear CL)
            forceScale: 1.0,     // Force scale for section analysis
            angularResolution: 1.0,  // Angular resolution in degrees (0.333 to 15)
            paused: false,       // Pause rotation
            manualRotation: 0,   // Manual rotation angle in degrees
            windFarmMode: false, // Enable multiple turbines
            farmTurbineCount: 5, // Total turbines in wind farm
            speedVariation: 0.05, // ¬±5% speed variation
            removeMean: false,   // Remove 0P (mean) component from loads
            debugSinusoid: false, // Debug mode: replace loads with pure sinusoid
            // Dynamic speed mode parameters
            dynamicSpeed: false, // Use physics-based speed
            rotorInertia: 1000000, // Rotor moment of inertia (kg‚ãÖm¬≤)
            generatorTorque: 50000, // Generator resistance torque (N‚ãÖm)
            dampingCoeff: 5000,  // Damping coefficient for stability
            angularVelocity: 15 * 2 * Math.PI / 60   // Current angular velocity (rad/s), initialized to match shaftSpeed (TSR ‚âà 4.5)
        };
        
        // Data history for plotting
        // After fast Fourier, traces will scroll continuously
        const plotData = {
            time: [],           // Now represents continuous time, not azimuth
            bladeLift: [],
            bladeMomentY: [],
            bladeMomentZ: [],
            bladeAoA: [],       // Angle of Attack (per blade, no total)
            bladeVelocity: [],  // Total Velocity (per blade, no total)
            bladeLiftForce: [], // Lift force L (per blade)
            bladeTangentialVelocity: [], // Tangential velocity Vt (per blade)
            totalLift: [],
            totalMomentY: [],
            totalMomentZ: [],
            timeValue: 0,       // Continuous time counter (in radians)
            tdcMarkers: []      // Track when blade 1 hits top dead center (azimuth = 0)
        };
        
        // Fourier analysis data collection
        const fourierData = {
            collecting: false,
            startAzimuth: 0,
            bladeLift: [],
            bladeMomentY: [],
            bladeMomentZ: [],
            bladeAoA: [],       // Angle of Attack Fourier data
            bladeVelocity: [],  // Total Velocity Fourier data
            bladeLiftForce: [], // Lift force L Fourier data
            bladeTangentialVelocity: [], // Tangential velocity Vt Fourier data
            totalLift: [],
            totalMomentY: [],
            totalMomentZ: [],
            complete: false,
            everCompleted: false,  // Track if we've ever had valid data (for display during re-collection)
            fastMode: false,  // Use fast collection for first revolution
            lastCollectionTime: 0,
            samplingInterval: 0,
            speedMultiplier: 5  // Speed up rotation by this factor during fast collection
        };
        
        // Wind farm additional turbines
        let additionalTurbines = [];
        
        let timeCounter = 0;
        
        function initPlotData() {
            plotData.time = [];
            plotData.bladeLift = [];
            plotData.bladeMomentY = [];
            plotData.bladeMomentZ = [];
            plotData.bladeAoA = [];
            plotData.bladeVelocity = [];
            plotData.bladeLiftForce = [];
            plotData.bladeTangentialVelocity = [];
            plotData.totalLift = [];
            plotData.totalMomentY = [];
            plotData.totalMomentZ = [];
            plotData.totalThrust = [];  // New: total rotor thrust
            plotData.totalTorque = [];  // New: total rotor torque
            plotData.totalHubMoment = [];  // New: total hub moment magnitude
            plotData.timeValue = 0;
            plotData.tdcMarkers = [];
            for (let i = 0; i < turbineParams.numBlades; i++) {
                plotData.bladeLift[i] = [];
                plotData.bladeMomentY[i] = [];
                plotData.bladeMomentZ[i] = [];
                plotData.bladeAoA[i] = [];
                plotData.bladeVelocity[i] = [];
                plotData.bladeLiftForce[i] = [];
                plotData.bladeTangentialVelocity[i] = [];
            }
            timeCounter = 0;
        }
        
        initPlotData();
        
        // Reset Fourier analysis collection
        function resetFourierCollection() {
            fourierData.collecting = false;
            fourierData.complete = false;
            fourierData.bladeLift = [];
            fourierData.bladeMomentY = [];
            fourierData.bladeMomentZ = [];
            fourierData.bladeAoA = [];
            fourierData.bladeVelocity = [];
            fourierData.bladeLiftForce = [];
            fourierData.bladeTangentialVelocity = [];
            fourierData.totalLift = [];
            fourierData.totalMomentY = [];
            fourierData.totalMomentZ = [];
            fourierData.totalThrust = [];  // New
            fourierData.totalTorque = [];  // New
            fourierData.totalHubMoment = [];  // New
            fourierData.fastMode = true; // Next collection will be fast
        }
        
        // Start Fourier collection at current azimuth
        function startFourierCollection() {
            const currentAzimuthRad = rotorGroup.rotation.x;
            fourierData.startAzimuth = currentAzimuthRad;
            fourierData.collecting = true;
            fourierData.complete = false;
            fourierData.bladeLift = [];
            fourierData.bladeMomentY = [];
            fourierData.bladeMomentZ = [];
            fourierData.totalLift = [];
            fourierData.totalMomentY = [];
            fourierData.totalMomentZ = [];
            fourierData.totalThrust = [];  // New
            fourierData.totalTorque = [];  // New
            fourierData.totalHubMoment = [];  // New
            
            // Set sampling interval based on mode
            if (fourierData.fastMode) {
                // Fast mode: collect ~36-72 points per revolution (5-10 degree steps)
                fourierData.samplingInterval = Math.max(5, turbineParams.angularResolution);
            } else {
                // Normal mode: use current angular resolution
                fourierData.samplingInterval = turbineParams.angularResolution;
            }
            
            fourierData.lastCollectionTime = 0;
        }
        
        // Ground plane with shadow receiving and high-quality grass texture WITH UNDULATION
        const groundGeometry = new THREE.PlaneGeometry(1000, 1000, 150, 150); // High detail segments
        const vertices = groundGeometry.attributes.position.array;
        
        // Add rolling terrain undulation (same as photo mode)
        for (let i = 0; i < vertices.length; i += 3) {
            const x = vertices[i];
            const z = vertices[i + 1];
            const distance = Math.sqrt(x * x + z * z);
            
            // Multiple sine waves for natural-looking hills
            let height = Math.sin(x * 0.01) * 8 + Math.cos(z * 0.012) * 6;
            height += Math.sin(x * 0.03 + z * 0.02) * 3;
            height += Math.sin(distance * 0.008) * 12;
            height -= distance * 0.02; // Gentle slope down
            
            // Add valleys and ridges
            height += Math.sin(x * 0.005) * Math.cos(z * 0.006) * 5;
            
            vertices[i + 2] = height;
        }
        
        groundGeometry.computeVertexNormals();
        
        // Create high-quality procedural grass texture with fine detail
        const grassCanvas = document.createElement('canvas');
        grassCanvas.width = 1024; // Higher resolution
        grassCanvas.height = 1024;
        const grassCtx = grassCanvas.getContext('2d');
        
        // Fill with base grass color
        grassCtx.fillStyle = '#4a7c2f';
        grassCtx.fillRect(0, 0, 1024, 1024);
        
        // Add fine grass blade texture with multiple layers
        for (let layer = 0; layer < 3; layer++) {
            for (let i = 0; i < 8000; i++) {
                const x = Math.random() * 1024;
                const y = Math.random() * 1024;
                const brightness = 0.85 + Math.random() * 0.3;
                const length = 2 + Math.random() * 4;
                const width = 0.3 + Math.random() * 0.5;
                
                // Random grass blade color
                const r = Math.floor(74 * brightness);
                const g = Math.floor(124 * brightness);
                const b = Math.floor(47 * brightness);
                
                grassCtx.strokeStyle = `rgba(${r},${g},${b},${0.6 + Math.random() * 0.4})`;
                grassCtx.lineWidth = width;
                grassCtx.beginPath();
                grassCtx.moveTo(x, y);
                grassCtx.lineTo(x + (Math.random() - 0.5) * 2, y - length);
                grassCtx.stroke();
            }
        }
        
        // Add subtle dirt patches
        for (let i = 0; i < 100; i++) {
            const x = Math.random() * 1024;
            const y = Math.random() * 1024;
            const radius = 10 + Math.random() * 30;
            const gradient = grassCtx.createRadialGradient(x, y, 0, x, y, radius);
            gradient.addColorStop(0, 'rgba(90, 70, 40, 0.2)');
            gradient.addColorStop(1, 'rgba(90, 70, 40, 0)');
            grassCtx.fillStyle = gradient;
            grassCtx.fillRect(x - radius, y - radius, radius * 2, radius * 2);
        }
        
        const grassTexture = new THREE.CanvasTexture(grassCanvas);
        grassTexture.wrapS = grassTexture.wrapT = THREE.RepeatWrapping;
        grassTexture.repeat.set(80, 80); // More repetition for finer detail
        grassTexture.anisotropy = renderer.capabilities.getMaxAnisotropy(); // Max quality filtering
        
        const groundMaterial = new THREE.MeshStandardMaterial({
            map: grassTexture,
            roughness: 0.95,
            metalness: 0.0
        });
        ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2; // Rotate to be horizontal
        ground.position.y = 0; // At ground level
        ground.receiveShadow = true;
        scene.add(ground);
        
        // Function to calculate ground height at any position using same formula as terrain
        function getGroundHeightAt(x, z) {
            const distance = Math.sqrt(x * x + z * z);
            let height = Math.sin(x * 0.01) * 8 + Math.cos(z * 0.012) * 6;
            height += Math.sin(x * 0.03 + z * 0.02) * 3;
            height += Math.sin(distance * 0.008) * 12;
            height -= distance * 0.02;
            height += Math.sin(x * 0.005) * Math.cos(z * 0.006) * 5;
            return height;
        }
        
        // Calculate ground height at main turbine position (0, 0)
        const groundHeightAtTurbine = getGroundHeightAt(0, 0);
        
        // Tower - position base at ground height
        const towerGeometry = new THREE.CylinderGeometry(0.8, 1.2, turbineParams.towerHeight, 16);
        const towerMaterial = new THREE.MeshPhongMaterial({ color: 0xcccccc });
        const tower = new THREE.Mesh(towerGeometry, towerMaterial);
        tower.position.y = turbineParams.towerHeight / 2 + groundHeightAtTurbine;
        tower.castShadow = true;
        scene.add(tower);
        
        // Wind vector arrow (declare here so it's accessible in the function below)
        let windVectorArrow = null;
        
        // Create wind vector arrow
        function createWindVectorArrow() {
            // Only create/update if wind vector is enabled
            if (!turbineParams.showWindVector) {
                if (windVectorArrow) {
                    scene.remove(windVectorArrow);
                    windVectorArrow = null;
                }
                return;
            }
            
            // Remove old arrow if it exists
            if (windVectorArrow) {
                scene.remove(windVectorArrow);
            }
            
            // Calculate wind direction from yaw and inflow angles
            const V = turbineParams.windSpeed;
            const yawRad = turbineParams.yawAngle * Math.PI / 180;
            const inflowRad = turbineParams.inflowAngle * Math.PI / 180;
            
            // Wind velocity components - matching aerodynamics code AND rotor axes
            // Rotor axes: X = rotation axis (perpendicular to disc), Y-Z = disc plane
            // Base wind comes from -X direction (toward rotor from front)
            // x = axial (thrust direction) - NEGATIVE because wind comes from -X
            // y = vertical in-plane (inflow component)  
            // z = horizontal in-plane (yaw component) - POSITIVE for positive yaw (wind from right)
            const V_x = -V * Math.cos(inflowRad) * Math.cos(yawRad);  // Negative X for wind from front
            const V_y = V * Math.sin(inflowRad);
            const V_z = V * Math.sin(yawRad) * Math.cos(inflowRad);  // Positive Z for positive yaw
            
            // Wind velocity vector - points from upwind toward turbine
            const windVelocity = new THREE.Vector3(V_x, V_y, V_z).normalize();
            
            // Wind direction arrow points in direction of wind flow (toward turbine)
            const windDir = windVelocity.clone();
            
            // Position arrow in front of turbine (upwind side)
            const arrowLength = Math.max(V * 2, 10); // Scale with wind speed
            const hubHeight = turbineParams.towerHeight + groundHeightAtTurbine;
            const arrowOrigin = new THREE.Vector3(
                -windVelocity.x * 40, // 40m upwind (negative X direction)
                hubHeight - windVelocity.y * 40,
                -windVelocity.z * 40
            );
            
            // Create arrow (cyan color, highly visible) - points toward turbine
            windVectorArrow = new THREE.ArrowHelper(
                windDir,
                arrowOrigin,
                arrowLength,
                0x00ffff, // Cyan
                arrowLength * 0.3, // Head length
                arrowLength * 0.2  // Head width
            );
            
            // Make arrow thicker
            windVectorArrow.line.material.linewidth = 4;
            
            scene.add(windVectorArrow);
        }
        
        // Create initial wind arrow
        createWindVectorArrow();
        
        // Add infinite sky sphere
        const skyGeo = new THREE.SphereGeometry(10000, 64, 64);
        const skyMat = new THREE.ShaderMaterial({
            uniforms: {
                topColor: { value: new THREE.Color(0x0077ff) },
                horizonColor: { value: new THREE.Color(0x87ceeb) },
                sunColor: { value: new THREE.Color(0xffffff) }
            },
            vertexShader: `
                varying vec3 vWorldPosition;
                void main() {
                    vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                    vWorldPosition = worldPosition.xyz;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform vec3 topColor;
                uniform vec3 horizonColor;
                uniform vec3 sunColor;
                varying vec3 vWorldPosition;
                void main() {
                    vec3 direction = normalize(vWorldPosition);
                    float elevation = direction.y;
                    
                    vec3 color;
                    if (elevation > 0.0) {
                        float t = pow(elevation, 0.4);
                        color = mix(horizonColor, topColor, t);
                    } else {
                        float t = pow(abs(elevation), 0.6);
                        color = mix(horizonColor, sunColor, t * 0.3);
                    }
                    
                    gl_FragColor = vec4(color, 1.0);
                }
            `,
            side: THREE.BackSide,
            depthWrite: false,
            depthTest: false
        });
        skyboxMesh = new THREE.Mesh(skyGeo, skyMat);
        skyboxMesh.renderOrder = -1000;
        scene.add(skyboxMesh);
        
        // Add animated cloud layer
        const cloudGeometry = new THREE.PlaneGeometry(1500, 1500, 10, 10);
        const cloudCanvas = document.createElement('canvas');
        cloudCanvas.width = 512;
        cloudCanvas.height = 512;
        const cloudCtx = cloudCanvas.getContext('2d');
        cloudCtx.fillStyle = 'rgba(255, 255, 255, 0)';
        cloudCtx.fillRect(0, 0, 512, 512);
        for (let i = 0; i < 30; i++) {
            const cx = Math.random() * 512;
            const cy = Math.random() * 512;
            const radius = 30 + Math.random() * 70;
            const gradient = cloudCtx.createRadialGradient(cx, cy, 0, cx, cy, radius);
            gradient.addColorStop(0, `rgba(255, 255, 255, ${0.3 + Math.random() * 0.4})`);
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            cloudCtx.fillStyle = gradient;
            cloudCtx.fillRect(0, 0, 512, 512);
        }
        const cloudTexture = new THREE.CanvasTexture(cloudCanvas);
        cloudTexture.wrapS = cloudTexture.wrapT = THREE.RepeatWrapping;
        cloudTexture.repeat.set(3, 3);
        const cloudMaterial = new THREE.MeshBasicMaterial({
            map: cloudTexture,
            transparent: true,
            opacity: 0.5,
            side: THREE.DoubleSide,
            depthWrite: false
        });
        cloudPlane = new THREE.Mesh(cloudGeometry, cloudMaterial);
        cloudPlane.rotation.x = -Math.PI / 2;
        cloudPlane.position.y = 200;
        scene.add(cloudPlane);
        cloudOffset = 0;
        
        // Nacelle (rotates for yaw)
        const nacelleGroup = new THREE.Group();
        nacelleGroup.position.set(0, turbineParams.towerHeight + groundHeightAtTurbine, 0);
        scene.add(nacelleGroup);
        
        const nacelleGeometry = new THREE.BoxGeometry(4, 2, 2);
        const nacelleMaterial = new THREE.MeshPhongMaterial({ color: 0xeeeeee });
        const nacelle = new THREE.Mesh(nacelleGeometry, nacelleMaterial);
        nacelle.castShadow = true;
        nacelleGroup.add(nacelle);
        nacelleGroup.add(nacelleAxes);
        
        // Rotor group (contains hub and blades, rotates about X-axis)
        const rotorGroup = new THREE.Group();
        rotorGroup.position.x = 2;
        nacelleGroup.add(rotorGroup);
        rotorGroup.add(rotorAxes);
        
        // Hub
        const hubGeometry = new THREE.SphereGeometry(turbineParams.hubRadius, 16, 16);
        const hubMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 });
        const hub = new THREE.Mesh(hubGeometry, hubMaterial);
        hub.castShadow = true;
        rotorGroup.add(hub);
        
        // Cache initial materials for photo mode toggle
        cacheMaterial(tower);
        cacheMaterial(nacelle);
        cacheMaterial(hub);
        cacheMaterial(ground);
        
        // Blades
        const blades = [];
        const bladeSegments = [];
        let forceArrows = [];
        // windVectorArrow is now declared earlier (line 1001)
        
        // Section plane visualization (circular disc at selected radial station)
        let sectionPlane = null;
        
        function createSectionPlane() {
            if (sectionPlane) {
                rotorGroup.remove(sectionPlane);
            }
            
            const percent = turbineParams.radialStation;
            const radius = percent * turbineParams.bladeRadius;
            
            // Create a group for the section plane and all its elements
            sectionPlane = new THREE.Group();
            
            // Create a rectangular cutting plane that cuts through the blade
            // The plane should be perpendicular to the blade span (Y-axis)
            const planeSize = 6; // Square plane
            const planeGeometry = new THREE.PlaneGeometry(planeSize, planeSize);
            const planeMaterial = new THREE.MeshBasicMaterial({
                color: 0xffff00,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.15,
                depthWrite: false
            });
            
            const planeMesh = new THREE.Mesh(planeGeometry, planeMaterial);
            sectionPlane.add(planeMesh);
            
            // Now add all the section analysis elements from the 2D chart onto the 3D plane
            // Get the data from the section chart
            if (sectionChart && sectionChart.data && sectionChart.data.datasets) {
                const datasets = sectionChart.data.datasets;
                
                // Helper function to create a line from data points
                const createLine = (dataPoints, color, linewidth = 2, dashed = false) => {
                    if (!dataPoints || dataPoints.length < 2) return null;
                    
                    const points = dataPoints.map(p => {
                        // Convert 2D chart coordinates to 3D plane coordinates
                        // Chart uses x-y plane, map to plane's local coordinate system
                        // Since plane is rotated 90¬∞ around X-axis, we map:
                        // Chart X -> Local -X (flipped), Chart Y -> Local Y, Z=0
                        return new THREE.Vector3(-p.x, p.y, 0);
                    });
                    
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    const material = new THREE.LineBasicMaterial({ 
                        color: color,
                        linewidth: linewidth,
                        transparent: true,
                        opacity: 0.9
                    });
                    
                    if (dashed) {
                        material.dashSize = 0.1;
                        material.gapSize = 0.1;
                    }
                    
                    return new THREE.Line(geometry, material);
                };
                
                // Dataset indices (matching the chart configuration):
                // 0: Airfoil
                // 1: Vt, 2: Vn, 3: VR
                // 4: Lift, 5: Drag, 6: Resultant Force
                // 7: Thrust, 8: Tangential Force
                // 9: Chord Line
                // 10: œÜ, 11: Œ±, 12: Œ∏
                // 13: Chord Extension, 14: Vt Extension, 15: VR Extension
                
                // Check if dataset is hidden
                const isHidden = (index) => {
                    const meta = sectionChart.getDatasetMeta(index);
                    return meta && meta.hidden;
                };
                
                // Add airfoil outline (0)
                if (!isHidden(0)) {
                    const airfoilLine = createLine(datasets[0].data, 0x333333, 2);
                    if (airfoilLine) sectionPlane.add(airfoilLine);
                }
                
                // Add velocity vectors (1-3)
                if (!isHidden(1)) {
                    const vtLine = createLine(datasets[1].data, 0xff6384, 3);
                    if (vtLine) sectionPlane.add(vtLine);
                }
                if (!isHidden(2)) {
                    const vnLine = createLine(datasets[2].data, 0x36a2eb, 3);
                    if (vnLine) sectionPlane.add(vnLine);
                }
                if (!isHidden(3)) {
                    const vrLine = createLine(datasets[3].data, 0x4bc0c0, 3);
                    if (vrLine) sectionPlane.add(vrLine);
                }
                
                // Add force vectors (4-8)
                if (!isHidden(4)) {
                    const liftLine = createLine(datasets[4].data, 0x9966ff, 3);
                    if (liftLine) sectionPlane.add(liftLine);
                }
                if (!isHidden(5)) {
                    const dragLine = createLine(datasets[5].data, 0xff9f40, 3);
                    if (dragLine) sectionPlane.add(dragLine);
                }
                if (!isHidden(6)) {
                    const resultantLine = createLine(datasets[6].data, 0xff6384, 4);
                    if (resultantLine) sectionPlane.add(resultantLine);
                }
                if (!isHidden(7)) {
                    const thrustLine = createLine(datasets[7].data, 0x00cc00, 3);
                    if (thrustLine) sectionPlane.add(thrustLine);
                }
                if (!isHidden(8)) {
                    const tangentLine = createLine(datasets[8].data, 0xff00ff, 3);
                    if (tangentLine) sectionPlane.add(tangentLine);
                }
                
                // Add chord line (9)
                if (!isHidden(9)) {
                    const chordLine = createLine(datasets[9].data, 0x000000, 2, true);
                    if (chordLine) sectionPlane.add(chordLine);
                }
                
                // Add angle arcs (10-12)
                if (!isHidden(10)) {
                    const phiArc = createLine(datasets[10].data, 0x4bc0c0, 2);
                    if (phiArc) sectionPlane.add(phiArc);
                }
                if (!isHidden(11)) {
                    const alphaArc = createLine(datasets[11].data, 0x9966ff, 2);
                    if (alphaArc) sectionPlane.add(alphaArc);
                }
                if (!isHidden(12)) {
                    const thetaArc = createLine(datasets[12].data, 0xff6384, 2);
                    if (thetaArc) sectionPlane.add(thetaArc);
                }
                
                // Add extension lines (13-15) - dashed
                if (!isHidden(13)) {
                    const chordExt = createLine(datasets[13].data, 0x888888, 1, true);
                    if (chordExt) sectionPlane.add(chordExt);
                }
                if (!isHidden(14)) {
                    const vtExt = createLine(datasets[14].data, 0xff6384, 1, true);
                    if (vtExt) sectionPlane.add(vtExt);
                }
                if (!isHidden(15)) {
                    const vrExt = createLine(datasets[15].data, 0x4bc0c0, 1, true);
                    if (vrExt) sectionPlane.add(vrExt);
                }
            }
            
            // Position the plane at the radial station
            // Blade extends along Y-axis, so plane position.y = radius
            sectionPlane.position.x = 0;
            sectionPlane.position.y = radius;
            sectionPlane.position.z = 0;
            
            // Rotate plane 90¬∞ around X-axis so it's perpendicular to the blade span (Y-axis)
            // This makes it cut through the blade cross-section
            sectionPlane.rotation.x = Math.PI / 2;
            
            rotorGroup.add(sectionPlane);
        }
        
        function toggleSectionPlane(show) {
            if (show) {
                createSectionPlane();
            } else if (sectionPlane) {
                rotorGroup.remove(sectionPlane);
                sectionPlane = null;
            }
        }
        
        // Function to update opacity of all 3D objects except section plane
        function update3DModelOpacity(opacity) {
            // Helper function to set material opacity for a mesh
            const setMeshOpacity = (mesh) => {
                if (mesh && mesh.material) {
                    // Enable transparency if not already
                    mesh.material.transparent = true;
                    mesh.material.opacity = opacity;
                    mesh.material.needsUpdate = true;
                }
            };
            
            // Update main turbine components
            setMeshOpacity(tower);
            setMeshOpacity(nacelle);
            setMeshOpacity(hub);
            setMeshOpacity(ground);
            
            // Update all blade segments
            bladeSegments.forEach(setMeshOpacity);
            
            // Update skybox if it exists
            if (skyboxMesh) {
                setMeshOpacity(skyboxMesh);
            }
            
            // Update wind vector arrow if it exists
            if (windVectorArrow && windVectorArrow.line) {
                if (windVectorArrow.line.material) {
                    windVectorArrow.line.material.transparent = true;
                    windVectorArrow.line.material.opacity = opacity;
                    windVectorArrow.line.material.needsUpdate = true;
                }
                if (windVectorArrow.cone && windVectorArrow.cone.material) {
                    windVectorArrow.cone.material.transparent = true;
                    windVectorArrow.cone.material.opacity = opacity;
                    windVectorArrow.cone.material.needsUpdate = true;
                }
            }
            
            // Update clouds if they exist
            scene.traverse((object) => {
                if (object.name && object.name.startsWith('cloud')) {
                    setMeshOpacity(object);
                }
            });
            
            // NOTE: We intentionally skip the sectionPlane - it will keep full opacity
        }
        
        // Helper to iterate all meshes for photo mode
        function forEachMesh(fn){
            fn(tower); fn(nacelle); fn(hub); fn(ground);
            bladeSegments.forEach(fn);
        }
        
        // ============================================================
        // AIRFOIL DATA LOOKUP TABLES
        // Based on typical wind turbine airfoil performance characteristics
        // Representative of NREL S-series and similar modern wind turbine airfoils
        // ============================================================
        
        // Thin airfoil (18-21% thick) - Tip sections
        // High performance, low drag, designed for outer blade sections
        // Characteristics similar to NREL S818, S819, DU 91-W2-250
        const TIP_AIRFOIL_DATA = {
            thickness: 0.18,
            aoa: [-180, -170, -160, -150, -140, -130, -120, -110, -100, -90, -80, -70, -60, -50, -40, -30, -20, -15, -12, -10, -8, -6, -4, -2, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 25, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160, 170, 180],
            cl: [0, -0.25, -0.48, -0.68, -0.84, -0.95, -1.00, -0.98, -0.88, -0.71, -0.48, -0.25, -0.05, 0.20, 0.45, 0.68, 0.88, 1.02, 1.12, 1.18, 1.22, 1.25, 1.26, 1.26, 1.24, 1.21, 1.17, 1.11, 1.04, 0.96, 0.87, 0.78, 0.70, 0.62, 0.55, 0.42, 0.35, 0.25, 0.18, 0.12, 0.06, 0.00, -0.05, -0.10, -0.14, -0.17, -0.19, -0.20, -0.19, -0.17, -0.12, 0],
            cd: [0.020, 0.030, 0.050, 0.080, 0.120, 0.170, 0.230, 0.300, 0.380, 0.470, 0.560, 0.650, 0.730, 0.800, 0.850, 0.880, 0.890, 0.120, 0.048, 0.024, 0.013, 0.009, 0.007, 0.006, 0.006, 0.006, 0.007, 0.009, 0.012, 0.017, 0.024, 0.035, 0.050, 0.070, 0.095, 0.160, 0.240, 0.420, 0.600, 0.770, 0.920, 1.050, 1.150, 1.200, 1.210, 1.180, 1.120, 1.050, 0.970, 0.880, 0.780, 0.680]
        };
        
        // Mid-thickness airfoil (24-27% thick) - Mid-span sections
        // Balanced performance for middle blade sections  
        // Characteristics similar to NREL S825, S826, DU 93-W-210
        const MID_AIRFOIL_DATA = {
            thickness: 0.25,
            aoa: [-180, -170, -160, -150, -140, -130, -120, -110, -100, -90, -80, -70, -60, -50, -40, -30, -20, -15, -12, -10, -8, -6, -4, -2, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 25, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160, 170, 180],
            cl: [0, -0.28, -0.53, -0.74, -0.90, -1.00, -1.04, -1.00, -0.88, -0.68, -0.45, -0.22, -0.02, 0.22, 0.47, 0.70, 0.90, 1.04, 1.13, 1.18, 1.21, 1.22, 1.21, 1.18, 1.14, 1.09, 1.03, 0.96, 0.89, 0.82, 0.75, 0.68, 0.62, 0.56, 0.51, 0.40, 0.33, 0.23, 0.16, 0.10, 0.05, 0.00, -0.05, -0.09, -0.13, -0.16, -0.18, -0.19, -0.18, -0.16, -0.11, 0],
            cd: [0.025, 0.035, 0.055, 0.090, 0.135, 0.190, 0.255, 0.330, 0.415, 0.510, 0.610, 0.710, 0.800, 0.875, 0.930, 0.965, 0.980, 0.150, 0.062, 0.032, 0.018, 0.012, 0.010, 0.009, 0.009, 0.010, 0.011, 0.013, 0.017, 0.022, 0.030, 0.042, 0.058, 0.080, 0.108, 0.180, 0.270, 0.460, 0.650, 0.830, 0.990, 1.120, 1.210, 1.250, 1.250, 1.210, 1.140, 1.060, 0.970, 0.870, 0.760, 0.650]
        };
        
        // Thick airfoil (30-35% thick) - Root-transition sections
        // Structural emphasis, thicker for strength
        // Characteristics similar to NREL S830, DU 97-W-300
        const ROOT_AIRFOIL_DATA = {
            thickness: 0.30,
            aoa: [-180, -170, -160, -150, -140, -130, -120, -110, -100, -90, -80, -70, -60, -50, -40, -30, -20, -15, -12, -10, -8, -6, -4, -2, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 25, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160, 170, 180],
            cl: [0, -0.30, -0.57, -0.78, -0.94, -1.02, -1.04, -0.98, -0.85, -0.65, -0.42, -0.20, -0.01, 0.20, 0.43, 0.65, 0.84, 0.96, 1.03, 1.06, 1.07, 1.06, 1.03, 0.99, 0.94, 0.88, 0.82, 0.76, 0.70, 0.64, 0.59, 0.54, 0.50, 0.46, 0.43, 0.35, 0.29, 0.20, 0.14, 0.09, 0.04, 0.00, -0.04, -0.08, -0.12, -0.15, -0.17, -0.18, -0.17, -0.15, -0.10, 0],
            cd: [0.030, 0.042, 0.065, 0.105, 0.155, 0.220, 0.295, 0.380, 0.475, 0.580, 0.690, 0.795, 0.890, 0.965, 1.020, 1.050, 1.060, 0.200, 0.090, 0.050, 0.030, 0.020, 0.016, 0.014, 0.013, 0.014, 0.015, 0.018, 0.022, 0.028, 0.037, 0.050, 0.068, 0.092, 0.122, 0.205, 0.300, 0.500, 0.695, 0.880, 1.040, 1.170, 1.260, 1.300, 1.290, 1.240, 1.160, 1.070, 0.970, 0.860, 0.740, 0.620]
        };
        
        // Cylinder data for very thick root sections (40% thick)
        // Primarily structural, minimal aerodynamic performance
        const CYLINDER_DATA = {
            thickness: 0.40,
            aoa: [-180, -170, -160, -150, -140, -130, -120, -110, -100, -90, -80, -70, -60, -50, -40, -30, -20, -15, -12, -10, -8, -6, -4, -2, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 25, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160, 170, 180],
            cl: [0, -0.34, -0.64, -0.87, -0.99, -1.00, -0.87, -0.64, -0.34, 0, 0.34, 0.64, 0.87, 0.99, 1.00, 0.87, 0.64, 0.48, 0.38, 0.32, 0.26, 0.19, 0.13, 0.06, 0, -0.06, -0.13, -0.19, -0.26, -0.32, -0.38, -0.44, -0.50, -0.56, -0.62, -0.75, -0.87, -0.99, -1.00, -0.87, -0.64, -0.34, 0, 0.34, 0.64, 0.87, 0.99, 1.00, 0.87, 0.64, 0.34, 0],
            cd: [1.10, 1.05, 0.95, 0.82, 0.70, 0.62, 0.60, 0.65, 0.78, 0.98, 1.20, 1.40, 1.53, 1.58, 1.55, 1.43, 1.25, 1.15, 1.10, 1.08, 1.07, 1.05, 1.04, 1.02, 1.00, 1.02, 1.04, 1.05, 1.07, 1.08, 1.10, 1.12, 1.15, 1.18, 1.22, 1.32, 1.43, 1.58, 1.55, 1.43, 1.25, 1.05, 0.98, 1.05, 1.20, 1.40, 1.53, 1.55, 1.43, 1.25, 1.10, 1.10]
        };
        
        // Helper function: Linear interpolation
        function linearInterpolate(x, x1, x2, y1, y2) {
            if (x2 === x1) return y1;
            return y1 + (x - x1) * (y2 - y1) / (x2 - x1);
        }
        
        // Helper function: Find value in lookup table with interpolation
        function lookupAirfoilData(aoa_deg, dataTable) {
            const aoa = aoa_deg;
            const aoaArray = dataTable.aoa;
            const clArray = dataTable.cl;
            const cdArray = dataTable.cd;
            
            // Handle out of range (shouldn't happen with -180 to 180, but just in case)
            if (aoa <= aoaArray[0]) {
                return { cl: clArray[0], cd: cdArray[0] };
            }
            if (aoa >= aoaArray[aoaArray.length - 1]) {
                return { cl: clArray[clArray.length - 1], cd: cdArray[cdArray.length - 1] };
            }
            
            // Find the two nearest points and interpolate
            for (let i = 0; i < aoaArray.length - 1; i++) {
                if (aoa >= aoaArray[i] && aoa <= aoaArray[i + 1]) {
                    const cl = linearInterpolate(aoa, aoaArray[i], aoaArray[i + 1], clArray[i], clArray[i + 1]);
                    const cd = linearInterpolate(aoa, aoaArray[i], aoaArray[i + 1], cdArray[i], cdArray[i + 1]);
                    return { cl, cd };
                }
            }
            
            // Fallback (shouldn't reach here)
            return { cl: 0, cd: 0.02 };
        }
        
        // Select appropriate airfoil data table based on thickness ratio
        function selectAirfoilTable(thickness_ratio) {
            if (thickness_ratio > 0.35) {
                return CYLINDER_DATA;
            } else if (thickness_ratio > 0.275) {
                return ROOT_AIRFOIL_DATA;
            } else if (thickness_ratio > 0.215) {
                return MID_AIRFOIL_DATA;
            } else {
                return TIP_AIRFOIL_DATA;
            }
        }
        
        // Realistic lift coefficient function using lookup tables
        // Based on NREL airfoil data
        function getLiftCoefficient(aoa_deg, thickness_ratio) {
            // Simple aerodynamics mode: Linear lift model
            if (turbineParams.simpleAero) {
                const CL0 = 0.05;
                const Cl = CL0 + 5.7 * (aoa_deg * Math.PI / 180);
                return Cl;
            }
            
            // Select appropriate airfoil table
            let table1 = selectAirfoilTable(thickness_ratio);
            
            // If thickness matches exactly, use that table
            if (Math.abs(thickness_ratio - table1.thickness) < 0.01) {
                const data = lookupAirfoilData(aoa_deg, table1);
                return data.cl;
            }
            
            // Otherwise, interpolate between two tables
            let table2, t1, t2;
            
            if (thickness_ratio > table1.thickness) {
                // Interpolate upward
                if (table1.thickness === TIP_AIRFOIL_DATA.thickness) {
                    table2 = MID_AIRFOIL_DATA;
                } else if (table1.thickness === MID_AIRFOIL_DATA.thickness) {
                    table2 = ROOT_AIRFOIL_DATA;
                } else {
                    table2 = CYLINDER_DATA;
                }
                t1 = table1.thickness;
                t2 = table2.thickness;
            } else {
                // Interpolate downward
                if (table1.thickness === CYLINDER_DATA.thickness) {
                    table2 = ROOT_AIRFOIL_DATA;
                } else if (table1.thickness === ROOT_AIRFOIL_DATA.thickness) {
                    table2 = MID_AIRFOIL_DATA;
                } else {
                    table2 = TIP_AIRFOIL_DATA;
                }
                t2 = table1.thickness;
                t1 = table2.thickness;
                const temp = table1;
                table1 = table2;
                table2 = temp;
            }
            
            const data1 = lookupAirfoilData(aoa_deg, table1);
            const data2 = lookupAirfoilData(aoa_deg, table2);
            
            const cl = linearInterpolate(thickness_ratio, t1, t2, data1.cl, data2.cl);
            return cl;
        }
        
        // Realistic drag coefficient function using lookup tables
        // Based on NREL airfoil data
        function getDragCoefficient(aoa_deg, thickness_ratio, Cl = null) {
            // Simple aerodynamics mode: CD = 0.1 * CL
            if (turbineParams.simpleAero) {
                if (Cl === null) {
                    Cl = getLiftCoefficient(aoa_deg, thickness_ratio);
                }
                return Math.abs(0.1 * Cl);
            }
            
            // Select appropriate airfoil table
            let table1 = selectAirfoilTable(thickness_ratio);
            
            // If thickness matches exactly, use that table
            if (Math.abs(thickness_ratio - table1.thickness) < 0.01) {
                const data = lookupAirfoilData(aoa_deg, table1);
                return data.cd;
            }
            
            // Otherwise, interpolate between two tables
            let table2, t1, t2;
            
            if (thickness_ratio > table1.thickness) {
                // Interpolate upward
                if (table1.thickness === TIP_AIRFOIL_DATA.thickness) {
                    table2 = MID_AIRFOIL_DATA;
                } else if (table1.thickness === MID_AIRFOIL_DATA.thickness) {
                    table2 = ROOT_AIRFOIL_DATA;
                } else {
                    table2 = CYLINDER_DATA;
                }
                t1 = table1.thickness;
                t2 = table2.thickness;
            } else {
                // Interpolate downward
                if (table1.thickness === CYLINDER_DATA.thickness) {
                    table2 = ROOT_AIRFOIL_DATA;
                } else if (table1.thickness === ROOT_AIRFOIL_DATA.thickness) {
                    table2 = MID_AIRFOIL_DATA;
                } else {
                    table2 = TIP_AIRFOIL_DATA;
                }
                t2 = table1.thickness;
                t1 = table2.thickness;
                const temp = table1;
                table1 = table2;
                table2 = temp;
            }
            
            const data1 = lookupAirfoilData(aoa_deg, table1);
            const data2 = lookupAirfoilData(aoa_deg, table2);
            
            const cd = linearInterpolate(thickness_ratio, t1, t2, data1.cd, data2.cd);
            return cd;
        }
        
        // Create NREL-style airfoil cross-section with region-specific shapes
        // thickness_ratio: t/c (0.18 for tip, 0.40 for root)
        // spanFraction: 0 (root) to 1 (tip)
        function createAirfoilShape(chord, thickness_ratio, spanFraction) {
            const shape = new THREE.Shape();
            
            // Define airfoil characteristics based on span location (like NREL families)
            // Root region (0-30% span): Thick, structural, more circular
            // Mid region (30-70% span): Primary aerodynamic, moderate camber
            // Tip region (70-100% span): Thin, high-performance, less camber
            
            let camberAmount, maxThicknessLoc, leadingEdgeRadius;
            
            if (spanFraction < 0.3) {
                // Root region - thick structural airfoil
                camberAmount = 0.015;  // Less camber
                maxThicknessLoc = 0.35; // Thickness further back
                leadingEdgeRadius = 1.2; // Blunter leading edge
            } else if (spanFraction < 0.7) {
                // Mid-span region - primary aerodynamic airfoil
                camberAmount = 0.025;  // More camber for lift
                maxThicknessLoc = 0.30; // Standard location
                leadingEdgeRadius = 1.0; // Standard leading edge
            } else {
                // Tip region - thin high-performance airfoil
                camberAmount = 0.018;  // Moderate camber
                maxThicknessLoc = 0.28; // Thickness slightly forward
                leadingEdgeRadius = 0.8; // Sharper leading edge
            }
            
            // DEBUG MODE: Super extra camber to verify orientation
            if (turbineParams.debugCamber) {
                camberAmount = 0.15;  // 15% camber - super obvious!
            }
            
            const numPoints = 40;
            const points_upper = [];
            const points_lower = [];
            
            // Generate airfoil coordinates
            for (let i = 0; i <= numPoints; i++) {
                // Cosine spacing for better leading edge resolution
                const t = i / numPoints;
                const x = chord * (1 - Math.cos(t * Math.PI)) / 2;
                const x_norm = x / chord;
                
                // Modified NACA thickness distribution with adjustable parameters
                const yt = 5 * thickness_ratio * chord * leadingEdgeRadius * (
                    0.2969 * Math.sqrt(x_norm) -
                    0.1260 * x_norm -
                    0.3516 * x_norm * x_norm +
                    0.2843 * x_norm * x_norm * x_norm -
                    0.1036 * x_norm * x_norm * x_norm * x_norm
                );
                
                // Camber line - varies by region
                const camber = camberAmount * chord * 4 * (x_norm - x_norm * x_norm);
                
                // Flip airfoil 180¬∞ by negating X coordinate (LE should face forward into rotation)
                // Also negate camber to orient correctly in 3D space
                // Center at quarter chord: shift by -0.25*chord (so origin is at quarter chord, not mid-chord)
                points_upper.push(new THREE.Vector2(-(x - 0.25 * chord), -camber + yt));
                points_lower.push(new THREE.Vector2(-(x - 0.25 * chord), -camber - yt));
            }
            
            // Create shape (start at trailing edge, go around)
            shape.moveTo(points_upper[numPoints].x, points_upper[numPoints].y);
            
            // Upper surface (TE to LE)
            for (let i = numPoints; i >= 0; i--) {
                shape.lineTo(points_upper[i].x, points_upper[i].y);
            }
            
            // Lower surface (LE to TE)
            for (let i = 0; i <= numPoints; i++) {
                shape.lineTo(points_lower[i].x, points_lower[i].y);
            }
            
            return shape;
        }
        
        function createBlade() {
            const bladeGroup = new THREE.Group();
            
            // Pitch group for visual blade pitch
            const pitchGroup = new THREE.Group();
            bladeGroup.add(pitchGroup);
            
            const numSegments = 100;
            const segments = [];
            
            for (let i = 0; i < numSegments; i++) {
                const r = turbineParams.hubRadius + (i / numSegments) * (turbineParams.bladeRadius - turbineParams.hubRadius);
                const nextR = turbineParams.hubRadius + ((i + 1) / numSegments) * (turbineParams.bladeRadius - turbineParams.hubRadius);
                const segmentLength = nextR - r;
                
                const chord = 1.5 * (1 - i / numSegments) + 0.3;
                
                // Calculate twist for this segment
                // For constant AoA design: twist should vary to maintain constant flow angle
                // phi = atan(Vn/Vt) = atan(V_axial / (omega*r))
                // To maintain constant AoA, twist varies inversely with radius
                const spanFraction = i / numSegments;
                const r_norm = spanFraction;  // Normalized radius from 0 (root) to 1 (tip)
                
                // Use 1/r distribution for more optimal twist (maintains more constant AoA)
                // Avoid division by zero at root by using actual radius values
                const r_actual = turbineParams.hubRadius + r_norm * (turbineParams.bladeRadius - turbineParams.hubRadius);
                const r_root = turbineParams.hubRadius;
                const r_tip = turbineParams.bladeRadius;
                
                // Inverse radius weighting: twist(r) varies as 1/r for constant AoA
                const twist_weight = (r_tip / r_actual - 1) / (r_tip / r_root - 1);
                const twist = turbineParams.twistRoot * twist_weight + turbineParams.twistTip * (1 - twist_weight);
                
                // NREL-style thickness distribution: thick at root (40%), thin at tip (18%)
                // Root region: 40% t/c, Mid-span: 24-30% t/c, Tip: 18% t/c
                const thickness_ratio = 0.40 * (1 - spanFraction) + 0.18 * spanFraction;
                
                // Create airfoil shape and extrude along span (pass spanFraction for region-specific shapes)
                const airfoilShape = createAirfoilShape(chord, thickness_ratio, spanFraction);
                const extrudeSettings = {
                    depth: segmentLength,
                    bevelEnabled: false,
                    curveSegments: 12
                };
                
                const segmentGeometry = new THREE.ExtrudeGeometry(airfoilShape, extrudeSettings);
                
                // Rotate geometry to align with blade coordinates
                // Extrusion goes along Z, but we want it along Y (spanwise)
                segmentGeometry.rotateX(Math.PI / 2);
                
                const segmentMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x4444ff,
                    shininess: 30,
                    specular: 0x222222,
                    side: THREE.DoubleSide  // Render both sides for better visibility
                });
                const segment = new THREE.Mesh(segmentGeometry, segmentMaterial);
                
                segment.position.y = r;
                segment.castShadow = true;
                segment.receiveShadow = true;
                
                // Apply twist rotation to segment geometry
                segment.rotation.y = twist * Math.PI / 180;  // Convert twist to radians and rotate around span-wise axis
                
                segment.userData.radius = r + segmentLength / 2;
                segment.userData.chord = chord;
                segment.userData.twist = twist;
                
                pitchGroup.add(segment);
                segments.push(segment);
                bladeSegments.push(segment);
                cacheMaterial(segment); // Cache for photo mode
            }
            
            bladeGroup.segments = segments;
            bladeGroup.pitchGroup = pitchGroup;
            
            // Rotate blade to extend radially
            bladeGroup.rotation.y = Math.PI / 2;
            
            return bladeGroup;
        }
        
        function updateBladeCount() {
            blades.forEach(blade => rotorGroup.remove(blade));
            blades.length = 0;
            bladeSegments.length = 0;
            
            for (let i = 0; i < turbineParams.numBlades; i++) {
                const blade = createBlade();
                blade.rotation.x = (i * 2 * Math.PI) / turbineParams.numBlades;
                
                // Apply initial pitch angle to visual blade
                const actualPitchAngle = turbineParams.bladePitch - 90;
                blade.pitchGroup.rotation.y = actualPitchAngle * Math.PI / 180;
                
                rotorGroup.add(blade);
                blades.push(blade);
                
                // Tag all segments with their blade index
                blade.segments.forEach(segment => {
                    segment.userData.bladeIndex = i;
                });
            }
            
            // Reset plot data when blade count changes
            initPlotData();
            if (typeof liftChart !== 'undefined') {
                rebuildCharts();
            }
            resetFourierCollection();
        }
        
        // Create wind farm with multiple turbines
        function createWindFarm() {
            // Clear existing additional turbines
            additionalTurbines.forEach(t => {
                // Dispose of geometries and materials
                t.traverse(child => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(m => m.dispose());
                        } else {
                            child.material.dispose();
                        }
                    }
                });
                scene.remove(t);
            });
            additionalTurbines = [];
            
            if (!turbineParams.windFarmMode) return;
            
            // Preset positions for additional 4 turbines (main turbine at 0,0)
            const positions = [
                {x: -60, z: -40},
                {x: 60, z: -40},
                {x: -60, z: 40},
                {x: 60, z: 40}
            ];
            
            positions.forEach((pos, i) => {
                // Calculate ground height at this turbine's position
                const groundHeight = getGroundHeightAt(pos.x, pos.z);
                
                const turbineGroup = new THREE.Group();
                turbineGroup.position.set(pos.x, groundHeight, pos.z);
                
                // Speed variation for this turbine
                const speedMultiplier = 1 + (Math.random() - 0.5) * 2 * turbineParams.speedVariation;
                turbineGroup.userData.speedMultiplier = speedMultiplier;
                
                // Clone tower
                const towerGeo = new THREE.CylinderGeometry(0.8, 1.2, turbineParams.towerHeight, 16);
                const towerMat = new THREE.MeshPhongMaterial({ color: 0xcccccc });
                const towerClone = new THREE.Mesh(towerGeo, towerMat);
                towerClone.position.y = turbineParams.towerHeight / 2;
                towerClone.castShadow = true;
                turbineGroup.add(towerClone);
                
                // Clone nacelle group
                const nacelleGrp = new THREE.Group();
                nacelleGrp.position.set(0, turbineParams.towerHeight, 0);
                
                const nacelleGeo = new THREE.BoxGeometry(4, 2, 2);
                const nacelleMat = new THREE.MeshPhongMaterial({ color: 0xeeeeee });
                const nacelleClone = new THREE.Mesh(nacelleGeo, nacelleMat);
                nacelleClone.castShadow = true;
                nacelleGrp.add(nacelleClone);
                turbineGroup.add(nacelleGrp);
                
                // Clone rotor group
                const rotorGrp = new THREE.Group();
                rotorGrp.position.x = 2;
                nacelleGrp.add(rotorGrp);
                
                // Clone hub
                const hubGeo = new THREE.SphereGeometry(turbineParams.hubRadius, 16, 16);
                const hubMat = new THREE.MeshPhongMaterial({ color: 0x888888 });
                const hubClone = new THREE.Mesh(hubGeo, hubMat);
                hubClone.castShadow = true;
                rotorGrp.add(hubClone);
                
                // Clone blades
                for (let j = 0; j < turbineParams.numBlades; j++) {
                    const bladeGroup = new THREE.Group();
                    const pitchGroup = new THREE.Group();
                    bladeGroup.add(pitchGroup);
                    
                    const numSegments = 20; // Simpler blades for performance
                    for (let k = 0; k < numSegments; k++) {
                        const r = turbineParams.hubRadius + (k / numSegments) * (turbineParams.bladeRadius - turbineParams.hubRadius);
                        const nextR = turbineParams.hubRadius + ((k + 1) / numSegments) * (turbineParams.bladeRadius - turbineParams.hubRadius);
                        const segmentLength = nextR - r;
                        const chord = 1.5 * (1 - k / numSegments) + 0.3;
                        
                        const segGeo = new THREE.BoxGeometry(0.2, segmentLength, chord);
                        const segMat = new THREE.MeshPhongMaterial({ color: 0x4444ff });
                        const segment = new THREE.Mesh(segGeo, segMat);
                        segment.position.y = r + segmentLength / 2;
                        segment.castShadow = true;
                        pitchGroup.add(segment);
                    }
                    
                    bladeGroup.rotation.y = Math.PI / 2;
                    bladeGroup.rotation.x = (j * 2 * Math.PI) / turbineParams.numBlades;
                    rotorGrp.add(bladeGroup);
                }
                
                turbineGroup.userData.rotorGroup = rotorGrp;
                turbineGroup.userData.nacelleGroup = nacelleGrp;
                
                scene.add(turbineGroup);
                additionalTurbines.push(turbineGroup);
            });
        }
        
        // Color mapping function (enhanced with more stops)
        function getLoadColor(normalizedLoad) {
            const colors = [
                { pos: 0.0, color: new THREE.Color(0x0000ff) },   // Blue
                { pos: 0.14, color: new THREE.Color(0x0080ff) },  // Light blue
                { pos: 0.28, color: new THREE.Color(0x00ffff) },  // Cyan
                { pos: 0.42, color: new THREE.Color(0x00ff00) },  // Green
                { pos: 0.57, color: new THREE.Color(0xffff00) },  // Yellow
                { pos: 0.71, color: new THREE.Color(0xff8000) },  // Orange
                { pos: 0.85, color: new THREE.Color(0xff0000) },  // Red
                { pos: 1.0, color: new THREE.Color(0x8b0000) }    // Dark red
            ];
            
            for (let i = 0; i < colors.length - 1; i++) {
                if (normalizedLoad >= colors[i].pos && normalizedLoad <= colors[i + 1].pos) {
                    const t = (normalizedLoad - colors[i].pos) / (colors[i + 1].pos - colors[i].pos);
                    return new THREE.Color().lerpColors(colors[i].color, colors[i + 1].color, t);
                }
            }
            return colors[colors.length - 1].color;
        }
        
        // Update blade loads
        function updateBladeLoads() {
            const omega = turbineParams.shaftSpeed * 2 * Math.PI / 60;
            const windSpeed = turbineParams.windSpeed;
            const yawRadians = turbineParams.yawAngle * Math.PI / 180;
            const inflowRadians = turbineParams.inflowAngle * Math.PI / 180;
            
            // Wind speed components due to yaw
            const windSpeedAxial = windSpeed * Math.cos(yawRadians);
            const windSpeedTangential = windSpeed * Math.sin(yawRadians);
            
            let maxLoad = -Infinity;
            let minLoad = Infinity;
            let totalAoA = 0;
            let aoaCount = 0;
            
            blades.forEach((blade, bladeIndex) => {
                // Calculate azimuth from blade's actual rotation in the rotor
                // blade.rotation.x is the blade's offset, rotorGroup.rotation.x is the current rotor angle
                const azimuth = rotorGroup.rotation.x + blade.rotation.x;
                
                // Store azimuth at blade level for consistent data collection
                blade.userData.currentAzimuth = azimuth;
                
                blade.segments.forEach((segment, segIdx) => {
                    const r = segment.userData.radius;
                    const chord = segment.userData.chord;
                    
                    // Blade twist distribution (optimal for constant AoA)
                    // Varies inversely with radius to maintain constant flow angle
                    const r_norm = (r - turbineParams.hubRadius) / (turbineParams.bladeRadius - turbineParams.hubRadius);
                    const r_root = turbineParams.hubRadius;
                    const r_tip = turbineParams.bladeRadius;
                    const twist_weight = (r_tip / r - 1) / (r_tip / r_root - 1);
                    const twist = turbineParams.twistRoot * twist_weight + turbineParams.twistTip * (1 - twist_weight);
                    
                    // Velocities in rotor disc coordinates
                    // alpha = angle of attack (inflow), beta = sideslip (yaw)
                    // Disc velocity components:
                    // x = V sin(beta) - horizontal in-plane
                    // y = V sin(alpha) cos(beta) - vertical in-plane  
                    // z = V cos(alpha) cos(beta) - axial (thrust direction)
                    
                    const V = turbineParams.windSpeed;
                    const alpha = inflowRadians;
                    const beta = yawRadians;
                    
                    const V_x = V * Math.sin(beta);
                    const V_y = V * Math.sin(alpha) * Math.cos(beta);
                    const V_z = V * Math.cos(alpha) * Math.cos(beta);
                    
                    // In-plane velocity component at blade azimuth (perpendicular to radius)
                    // This adds to tangential velocity
                    const V_inplane_tangential = V_x * Math.cos(azimuth) - V_y * Math.sin(azimuth);
                    
                    // Tangential velocity (rotation + in-plane wind)
                    const Vt = omega * r + V_inplane_tangential;
                    
                    // Normal velocity (axial wind + induction)
                    const Vn = V_z * (1 - 0.3); // With induction factor - should be positive
                    
                    // Flow angle and angle of attack
                    const phi = Math.atan2(Vn, Vt);
                    // Use bladePitch directly for aerodynamics (slider value is the aerodynamic angle)
                    const aeroPitchAngle = turbineParams.bladePitch;
                    const totalBladeAngle = twist + aeroPitchAngle;
                    const bladeAngleGeometric = 90 - totalBladeAngle;
                    // AoA = phi - blade angle (geometric)
                    const aoa = (phi * 180 / Math.PI) - bladeAngleGeometric;
                    
                    totalAoA += aoa;
                    aoaCount++;
                    
                    // Dynamic pressure
                    const V_total = Math.sqrt(Vt * Vt + Vn * Vn);
                    const q = 0.5 * 1.225 * V_total * V_total * chord * (turbineParams.bladeRadius / 100);
                    
                    // Realistic aerodynamic model with stall
                    // Get thickness ratio for this span location
                    const spanFrac = (r - turbineParams.hubRadius) / (turbineParams.bladeRadius - turbineParams.hubRadius);
                    const thickness_ratio = 0.40 * (1 - spanFrac) + 0.18 * spanFrac;
                    
                    // Get lift and drag coefficients
                    const Cl = getLiftCoefficient(aoa, thickness_ratio);
                    const Cd = getDragCoefficient(aoa, thickness_ratio, Cl);
                    
                    const L = q * Cl;
                    const D = q * Cd;
                    
                    // Thrust (axial force)
                    let thrust = L * Math.cos(phi) + D * Math.sin(phi);
                    
                    // Tangential force (drives rotation)
                    let tangentialForce = L * Math.sin(phi) - D * Math.cos(phi);
                    
                    // Resultant force (magnitude of total force)
                    let resultantForce = Math.sqrt(L*L + D*D);
                    
                    // Debug mode: replace loads with pure sinusoid
                    if (turbineParams.debugSinusoid) {
                        // Pure sinusoid: F(œà) = F0 * (1 + sin(œà))
                        // This gives a simple 1P variation for testing moment calculations
                        const baseLoad = 1000; // Base load amplitude
                        const sinusoidalLoad = baseLoad * (1 + Math.sin(azimuth));
                        thrust = sinusoidalLoad;
                        tangentialForce = sinusoidalLoad * 0.1; // Small tangential component
                        resultantForce = sinusoidalLoad;
                    }
                    
                    // Store values (including azimuth for consistent plotting)
                    const load = Math.abs(thrust);
                    segment.userData.load = load;
                    segment.userData.aoa = aoa;
                    segment.userData.totalVelocity = V_total;
                    segment.userData.azimuth = azimuth;
                    segment.userData.thrust = thrust;
                    segment.userData.tangentialForce = tangentialForce;
                    segment.userData.resultantForce = resultantForce;
                    segment.userData.L = L;  // Store lift for resultant vector
                    segment.userData.D = D;  // Store drag for resultant vector
                    segment.userData.phi = phi;  // Store flow angle for resultant vector
                    segment.userData.Vn = Vn;  // Store normal velocity
                    segment.userData.Vt = Vt;  // Store tangential velocity
                    segment.userData.Cl = Cl;  // Store lift coefficient
                    segment.userData.Cd = Cd;  // Store drag coefficient
                    
                    if (load > maxLoad) maxLoad = load;
                    if (load < minLoad) minLoad = load;
                });
            });
            
            // Update force vectors visualization - show as load distribution
            if (turbineParams.showVectors) {
                // Properly dispose of old geometries and materials to prevent memory leaks
                forceArrows.forEach(arrow => {
                    scene.remove(arrow);
                    if (arrow.geometry) arrow.geometry.dispose();
                    if (arrow.material) arrow.material.dispose();
                });
                forceArrows = [];
                
                blades.forEach((blade, bladeIndex) => {
                    // Skip blades if single blade mode
                    if (turbineParams.vectorMode === 'single' && bladeIndex !== 0) return;
                    
                    const points = [];
                    const basePoints = [];
                    
                    // Collect points for load distribution curve
                    blade.segments.forEach((segment, segIdx) => {
                        const L = segment.userData.L || 0;
                        const D = segment.userData.D || 0;
                        const Vn = segment.userData.Vn || 0;
                        const Vt = segment.userData.Vt || 0;
                        
                        // Get segment world position (center of segment in 3D, now at quarter chord)
                        // Both 2D and 3D are now centered at quarter chord, so no offset needed
                        const worldPos = new THREE.Vector3();
                        segment.getWorldPosition(worldPos);
                        basePoints.push(worldPos.clone());
                        
                        const V_mag = Math.sqrt(Vn*Vn + Vt*Vt);
                        if (V_mag === 0) {
                            points.push(worldPos.clone());
                            return;
                        }
                        
                        // Calculate resultant force EXACTLY as in section analysis (2D chart)
                        // Lift: perpendicular to incoming flow, points "up" from airfoil
                        // Flow comes from direction (Vn, Vt), lift is perpendicular (rotated 90¬∞ CW)
                        // Perpendicular to (Vn, Vt) rotated 90¬∞ CW is (Vt, -Vn)
                        const forceScale = 0.005 * turbineParams.forceScale;
                        const lift_x = L * (Vt / V_mag) * forceScale;  // Perpendicular to flow
                        const lift_y = -L * (Vn / V_mag) * forceScale;   // Perpendicular to flow
                        
                        // Drag: parallel to velocity (pointing away from blade, in direction of flow)
                        const drag_x = D * (Vn / V_mag) * forceScale;
                        const drag_y = D * (Vt / V_mag) * forceScale;
                        
                        // Resultant force vector: vector sum of lift and drag
                        const resultant_x = lift_x + drag_x;
                        const resultant_y = lift_y + drag_y;
                        
                        // Apply the EXACT transformation used for section plane overlay
                        // Chart X -> Local -X, Chart Y -> Local Y, Z=0
                        const forceVecLocal = new THREE.Vector3(-resultant_x, resultant_y, 0);
                        
                        // Get blade rotation to transform to world space
                        const bladeRotationX = rotorGroup.rotation.x; // Rotor azimuthal position
                        const rotation = new THREE.Euler(Math.PI / 2 + bladeRotationX, 0, 0, 'XYZ');
                        const quaternion = new THREE.Quaternion().setFromEuler(rotation);
                        
                        // Transform force vector to world space
                        const forceVecWorld = forceVecLocal.clone().applyQuaternion(quaternion);
                        
                        const tipPos = worldPos.clone().add(forceVecWorld);
                        points.push(tipPos);
                    });
                    
                    // Create lines from base to tip for each segment
                    for (let i = 0; i < points.length; i++) {
                        const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                            basePoints[i],
                            points[i]
                        ]);
                        const lineMaterial = new THREE.LineBasicMaterial({ 
                            color: 0xff0000,
                            linewidth: 1,
                            transparent: true,
                            opacity: 0.6
                        });
                        const line = new THREE.Line(lineGeometry, lineMaterial);
                        scene.add(line);
                        forceArrows.push(line);
                    }
                    
                    // Create curve connecting all tips (load distribution envelope)
                    if (points.length > 1) {
                        const curveGeometry = new THREE.BufferGeometry().setFromPoints(points);
                        const curveMaterial = new THREE.LineBasicMaterial({ 
                            color: 0xff0000,
                            linewidth: 2
                        });
                        const curve = new THREE.Line(curveGeometry, curveMaterial);
                        scene.add(curve);
                        forceArrows.push(curve);
                    }
                });
            } else {
                // Hide vectors if disabled - properly dispose to prevent memory leaks
                forceArrows.forEach(arrow => {
                    scene.remove(arrow);
                    if (arrow.geometry) arrow.geometry.dispose();
                    if (arrow.material) arrow.material.dispose();
                });
                forceArrows = [];
            }
            
            // Calculate total rotor loads for display
            let totalThrust = 0;
            let totalTorque = 0;
            let totalMomentY = 0; // Nodding moment (about horizontal Y-axis in inertial frame)
            let totalMomentZ = 0; // Yawing moment (about vertical Z-axis in inertial frame)
            
            blades.forEach((blade, bladeIndex) => {
                // Each blade's azimuthal position (current rotor angle + blade offset)
                const bladeAzimuth = (rotorGroup.rotation.x + bladeIndex * 2 * Math.PI / turbineParams.numBlades);
                
                blade.segments.forEach(segment => {
                    const thrust = segment.userData.thrust || 0;
                    const tangentialForce = segment.userData.tangentialForce || 0;
                    const r = segment.position.y; // Radial distance (moment arm)
                    
                    totalThrust += thrust;
                    totalTorque += tangentialForce * r; // Torque = F_tangential * r
                    
                    // Hub moments from blade loads (in inertial/fixed frame)
                    // Coordinate system: X = downwind, Y = horizontal sideways, Z = vertical up
                    // Blade segment position in YZ plane: y = r*cos(œà), z = r*sin(œà)
                    // Thrust force is in +X direction
                    // Moments: M = r √ó F
                    // momentY (nodding, about Y-axis): M_y = F_x * z = thrust * r * sin(œà)
                    // momentZ (yawing, about Z-axis): M_z = -F_x * y = -thrust * r * cos(œà)
                    totalMomentY += thrust * r * Math.cos(bladeAzimuth);  // ‚úÖ NODDING
                    totalMomentZ += -thrust * r * Math.sin(bladeAzimuth); // ‚úÖ YAWING
                });
            });
            
            // Calculate total hub moment magnitude (resultant of yaw and nod moments)
            const totalHubMoment = Math.sqrt(totalMomentY * totalMomentY + totalMomentZ * totalMomentZ);
            
            // Store total loads for plotting
            turbineParams.currentTotalThrust = totalThrust;
            turbineParams.currentTotalTorque = totalTorque;
            turbineParams.currentTotalHubMoment = totalHubMoment;
            turbineParams.currentTotalMomentY = totalMomentY;  // Store full rotor moment Y
            turbineParams.currentTotalMomentZ = totalMomentZ;  // Store full rotor moment Z
            
            // Update rotor loads display
            updateRotorLoadsDisplay(totalThrust, totalTorque, totalHubMoment, totalMomentY, totalMomentZ);
            
            // Update section diagram immediately after loads are calculated (when not paused)
            if (!turbineParams.paused) {
                updateSectionDiagram();
            }
            
            // Apply mean removal to heatmap loads if enabled
            if (turbineParams.removeMean) {
                // Calculate mean thrust across all blade segments
                let totalThrust = 0;
                let segmentCount = 0;
                bladeSegments.forEach(segment => {
                    if (segment.userData.thrust !== undefined) {
                        totalThrust += segment.userData.thrust;
                        segmentCount++;
                    }
                });
                const meanThrust = segmentCount > 0 ? totalThrust / segmentCount : 0;
                
                // Recalculate loads with mean removed
                maxLoad = -Infinity;
                minLoad = Infinity;
                bladeSegments.forEach(segment => {
                    if (segment.userData.thrust !== undefined) {
                        const demeanedThrust = segment.userData.thrust - meanThrust;
                        const load = Math.abs(demeanedThrust);
                        segment.userData.load = load;
                        if (load > maxLoad) maxLoad = load;
                        if (load < minLoad) minLoad = load;
                    }
                });
            }
            
            // Autoscale and color segments
            const loadRange = maxLoad - minLoad;
            bladeSegments.forEach(segment => {
                // Check if we should color this segment based on vectorMode
                const shouldColor = turbineParams.vectorMode === 'all' || segment.userData.bladeIndex === 0;
                
                if (turbineParams.showHeatmap && shouldColor) {
                    const normalizedLoad = loadRange > 0 ? (segment.userData.load - minLoad) / loadRange : 0;
                    const color = getLoadColor(normalizedLoad);
                    if (isPhotoMode){
                        // tint base color slightly + glow with emissive
                        segment.material.color.lerp(color, 0.35);
                        if (segment.material.emissive) {
                            segment.material.emissive.lerp(color, 0.6);
                        }
                    } else {
                        segment.material.color = color.clone ? color.clone() : color;
                    }
                } else {
                    // Reset to neutral color when heatmap is off or not in display mode
                    const neutralColor = new THREE.Color(0xcccccc);
                    if (isPhotoMode && segment.material.emissive) {
                        segment.material.color.copy(neutralColor);
                        segment.material.emissive.set(0x000000);
                    } else {
                        segment.material.color.copy(neutralColor);
                    }
                }
            });
            
            // Update plot data
            if (omega > 0) {
                timeCounter++;
                
                // Calculate update interval based on angular resolution
                // angularResolution is in degrees, we need to convert to radians and calculate frames
                const degreesPerFrame = (turbineParams.shaftSpeed * 360) / (60 * 60); // degrees per frame at 60fps
                const framesPerSample = turbineParams.angularResolution / degreesPerFrame;
                const updateInterval = Math.max(1, Math.round(framesPerSample));
                
                // Only update plot data when not paused
                if (timeCounter % updateInterval === 0 && !turbineParams.paused) {
                    updatePlotData(omega);
                }
            }
        }
        
        // Calculate total aerodynamic torque on the rotor
        function calculateAerodynamicTorque() {
            let totalTorque = 0;
            const omega = turbineParams.angularVelocity; // Use actual angular velocity, not shaft speed
            
            blades.forEach((blade, bladeIndex) => {
                blade.segments.forEach((segment, segIdx) => {
                    const r = segment.userData.radius;
                    const L = segment.userData.L || 0;
                    const D = segment.userData.D || 0;
                    const phi = segment.userData.phi || 0;
                    
                    // Tangential force creates torque
                    // F_tangent = L * sin(phi) - D * cos(phi)
                    const F_tangent = L * Math.sin(phi) - D * Math.cos(phi);
                    
                    // Torque = force √ó radius
                    const segmentTorque = F_tangent * r;
                    totalTorque += segmentTorque;
                });
            });
            
            return totalTorque;
        }
        
        // Update rotor dynamics (called each frame when dynamicSpeed is enabled)
        function updateRotorDynamics(dt) {
            if (!turbineParams.dynamicSpeed || turbineParams.paused) return;
            
            // Calculate aerodynamic torque
            const T_aero = calculateAerodynamicTorque();
            
            // Generator torque (resistance) - proportional to speed squared (more realistic)
            const omega = turbineParams.angularVelocity;
            const T_gen = turbineParams.generatorTorque * Math.sign(omega) * (omega * omega) / (1.0 * 1.0); // Normalized to 1 rad/s
            
            // Damping torque (for stability)
            const T_damp = turbineParams.dampingCoeff * omega;
            
            // Startup assistance torque (helps turbine start from zero speed)
            // This simulates a motor or the fact that at very low speeds, the turbine can still catch the wind
            // Decays as speed increases
            const omega_threshold = 0.5; // rad/s - below this, add startup torque
            let T_startup = 0;
            if (omega < omega_threshold && turbineParams.windSpeed > 0) {
                // Startup torque proportional to wind speed, decreases with omega
                T_startup = 50000 * turbineParams.windSpeed * (1 - omega / omega_threshold);
            }
            
            // Net torque
            const T_net = T_aero + T_startup - T_gen - T_damp;
            
            // Angular acceleration = Torque / Inertia
            // Handle zero inertia case (instantaneous response)
            let alpha;
            if (turbineParams.rotorInertia > 0) {
                alpha = T_net / turbineParams.rotorInertia;
            } else {
                // Zero inertia: instantaneous equilibrium
                // Just maintain current speed or apply small change
                alpha = T_net * 0.0001; // Very small response to avoid instability
            }
            
            // Update angular velocity (Euler integration)
            turbineParams.angularVelocity += alpha * dt;
            
            // Prevent negative rotation (unphysical for wind turbine)
            if (turbineParams.angularVelocity < 0) {
                turbineParams.angularVelocity = 0;
            }
            
            // Update shaft speed in RPM for display
            turbineParams.shaftSpeed = turbineParams.angularVelocity * 60 / (2 * Math.PI);
            
            // Update the display
            document.getElementById('shaft-speed-value').textContent = turbineParams.shaftSpeed.toFixed(1);
            document.getElementById('shaft-speed').value = Math.min(20, turbineParams.shaftSpeed); // Clamp slider to max
        }
        
        // Photo Mode Enable/Disable Functions
        function enablePhotoMode(){
            if (isPhotoMode) return;
            isPhotoMode = true;

            // Renderer: physically-correct pipeline
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2; // Brighter for outdoor scene
            renderer.physicallyCorrectLights = true;

            // Enhanced lighting for photorealism
            // 1. Warm sunlight (5500K color temperature)
            directionalLight.color.setHex(0xffffee);
            directionalLight.intensity = 3.5;
            directionalLight.position.set(100, 80, 100); // More dramatic angle
            
            // 2. Enhanced shadow system (4096x4096 for crisp shadows)
            directionalLight.shadow.mapSize.set(4096, 4096);
            directionalLight.shadow.camera.left = -150;
            directionalLight.shadow.camera.right = 150;
            directionalLight.shadow.camera.top = 150;
            directionalLight.shadow.camera.bottom = -150;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 500;
            directionalLight.shadow.bias = -0.0001; // Prevent shadow acne
            directionalLight.shadow.radius = 2; // Softer shadow edges
            
            // 3. Hemisphere light for natural sky/ground bounce
            const hemiLight = new THREE.HemisphereLight(
                0x87ceeb,  // Sky color (light blue)
                0x4a7c2f,  // Ground color (grass green)
                0.6        // Intensity
            );
            hemiLight.position.set(0, 50, 0);
            scene.add(hemiLight);
            hemiLight.userData.isPhotoModeLight = true;
            
            // 4. Subtle rim light from opposite side
            const rimLight = new THREE.DirectionalLight(0xccddff, 0.3);
            rimLight.position.set(-80, 40, -80);
            scene.add(rimLight);
            rimLight.userData.isPhotoModeLight = true;
            
            // 5. Atmospheric fog for depth
            scene.fog = new THREE.FogExp2(0xe0f0ff, 0.0015); // Exponential fog, horizon color

            // HDRI env for reflections and background
            if (!pmremGen) pmremGen = new THREE.PMREMGenerator(renderer);
            new THREE.RGBELoader().load(PhotoConfig.HDRI_URL, (hdr)=>{
                const tex = pmremGen.fromEquirectangular(hdr).texture;
                envMap = tex;
                scene.environment = envMap; // For reflections on materials ONLY
                // Don't set scene.background - use gradient sky instead
                hdr.dispose();
            });
            
            // Create infinite-looking sky sphere that completely surrounds the scene
            const skyGeo = new THREE.SphereGeometry(10000, 64, 64); // HUGE sphere for true infinity feel
            const skyMat = new THREE.ShaderMaterial({
                uniforms: {
                    topColor: { value: new THREE.Color(0x0077ff) },      // Bright sky blue
                    horizonColor: { value: new THREE.Color(0x87ceeb) },  // Sky blue horizon
                    sunColor: { value: new THREE.Color(0xffffff) }       // White near horizon
                },
                vertexShader: `
                    varying vec3 vWorldPosition;
                    void main() {
                        vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                        vWorldPosition = worldPosition.xyz;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 topColor;
                    uniform vec3 horizonColor;
                    uniform vec3 sunColor;
                    varying vec3 vWorldPosition;
                    void main() {
                        // Normalized direction from center
                        vec3 direction = normalize(vWorldPosition);
                        float elevation = direction.y; // -1 (down) to +1 (up)
                        
                        vec3 color;
                        if (elevation > 0.0) {
                            // Sky above horizon: smooth blend from horizon to top
                            // Use exponential for more realistic atmosphere
                            float t = pow(elevation, 0.4);
                            color = mix(horizonColor, topColor, t);
                        } else {
                            // Below horizon: blend to lighter color (atmospheric glow)
                            float t = pow(abs(elevation), 0.6);
                            color = mix(horizonColor, sunColor, t * 0.3);
                        }
                        
                        gl_FragColor = vec4(color, 1.0);
                    }
                `,
                side: THREE.BackSide,
                depthWrite: false,
                depthTest: false
            });
            skyboxMesh = new THREE.Mesh(skyGeo, skyMat);
            skyboxMesh.renderOrder = -1000;
            scene.add(skyboxMesh);
            
            // Create animated cloud layer with procedural texture
            const cloudGeometry = new THREE.PlaneGeometry(1500, 1500, 10, 10);
            
            // Create procedural cloud texture using canvas
            const cloudCanvas = document.createElement('canvas');
            cloudCanvas.width = 512;
            cloudCanvas.height = 512;
            const ctx = cloudCanvas.getContext('2d');
            
            // Generate cloud-like pattern
            ctx.fillStyle = 'rgba(255, 255, 255, 0)';
            ctx.fillRect(0, 0, 512, 512);
            
            // Draw multiple layers of soft clouds
            for (let i = 0; i < 30; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                const radius = 30 + Math.random() * 70;
                const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
                gradient.addColorStop(0, `rgba(255, 255, 255, ${0.3 + Math.random() * 0.4})`);
                gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, 512, 512);
            }
            
            const cloudTexture = new THREE.CanvasTexture(cloudCanvas);
            cloudTexture.wrapS = cloudTexture.wrapT = THREE.RepeatWrapping;
            cloudTexture.repeat.set(3, 3);
            
            const cloudMaterial = new THREE.MeshBasicMaterial({
                map: cloudTexture,
                transparent: true,
                opacity: 0.5,
                side: THREE.DoubleSide,
                depthWrite: false
            });
            
            cloudPlane = new THREE.Mesh(cloudGeometry, cloudMaterial);
            cloudPlane.rotation.x = -Math.PI / 2; // Face up
            cloudPlane.position.y = 200; // High in the sky
            cloudPlane.userData.isCloudLayer = true;
            scene.add(cloudPlane);
            
            // SKIP gradient skybox - using HDRI as background instead
            // The HDRI background is set above via scene.background = envMap
            
            // Add sun disk for realism
            const sunGeo = new THREE.SphereGeometry(15, 16, 16);
            const sunMat = new THREE.MeshBasicMaterial({
                color: 0xffffdd,
                fog: false
            });
            const sunMesh = new THREE.Mesh(sunGeo, sunMat);
            sunMesh.position.set(450, 350, 450); // Position relative to sun direction
            sunMesh.userData.isSun = true;
            scene.add(sunMesh);
            
            // SKIP duplicate terrain - now using shared terrain in both modes
            // The main scene terrain already has the same undulation
            
            // Don't hide ground - we're using the same terrain in both modes
            // ground.visible = true; // Keep it visible

            // Swap to enhanced PBR materials
            forEachMesh((m)=>{
                const old = OriginalMats.get(m);
                if (!old.userData?.__pbrClone){
                    let pbr;
                    if (m === tower) {
                        // Tower: Painted metal (more metallic, less rough)
                        pbr = new THREE.MeshPhysicalMaterial({
                            color: 0xe5e5e5,
                            metalness: 0.85,
                            roughness: 0.2,
                            clearcoat: 0.3,
                            clearcoatRoughness: 0.25,
                            envMapIntensity: 1.2
                        });
                    } else if (m === nacelle) {
                        // Nacelle: Painted metal housing
                        pbr = new THREE.MeshPhysicalMaterial({
                            color: 0xf0f0f0,
                            metalness: 0.8,
                            roughness: 0.25,
                            clearcoat: 0.4,
                            clearcoatRoughness: 0.2,
                            envMapIntensity: 1.2
                        });
                    } else if (m === hub) {
                        // Hub: Cast iron/steel (darker, more metal)
                        pbr = new THREE.MeshPhysicalMaterial({
                            color: 0x666666,
                            metalness: 0.8,
                            roughness: 0.3,
                            clearcoat: 0.2,
                            clearcoatRoughness: 0.4,
                            envMapIntensity: 1.0
                        });
                    } else if (m === ground) {
                        // Ground (not used in photo mode, but handle anyway)
                        pbr = new THREE.MeshStandardMaterial({
                            color: 0x4a7c59,
                            roughness: 0.9,
                            metalness: 0.0
                        });
                    } else {
                        // Blades: Composite material with clearcoat
                        pbr = new THREE.MeshPhysicalMaterial({
                            color: 0xdddddd,
                            metalness: 0.1,
                            roughness: 0.4,
                            clearcoat: 0.6, // Glossy composite finish
                            clearcoatRoughness: 0.25,
                            envMapIntensity: 0.8
                        });
                    }
                    old.userData = old.userData || {};
                    old.userData.__pbrClone = pbr;
                    m.material = pbr;
                } else {
                    m.material = old.userData.__pbrClone;
                }
            });

            // Keep your load heatmap‚Äîuse emissive so PBR still reads
            bladeSegments.forEach(seg=>{
                seg.material.emissive = new THREE.Color(0x000000);
                seg.material.emissiveIntensity = 0.6;
            });

            // Enhanced postprocessing stack
            composer = new THREE.EffectComposer(renderer);
            renderPass = new THREE.RenderPass(scene, camera);
            composer.addPass(renderPass);

            // Subtle bloom for highlights (reduced for realism)
            bloomPass = new THREE.UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                0.25,  // Reduced strength (was 0.35)
                0.8,   // Radius
                0.9    // Higher threshold (was 0.85) - less bloom on normal objects
            );
            composer.addPass(bloomPass);

            // Only add bokeh if enabled (reduces background blur)
            if (PhotoConfig.useBokeh) {
                bokehPass = new THREE.BokehPass(scene, camera, {
                    focus: PhotoConfig.bokehFocusFar,
                    aperture: PhotoConfig.bokehAperture,
                    maxblur: PhotoConfig.bokehMaxBlur
                });
                composer.addPass(bokehPass);
            }

            fxaaPass = new THREE.ShaderPass(THREE.FXAAShader);
            fxaaPass.material.uniforms['resolution'].value.set(1 / window.innerWidth, 1 / window.innerHeight);
            composer.addPass(fxaaPass);

            // Optional: lighten fog or remove for hero look
            scene.fog = null;
        }

        function disablePhotoMode(){
            if (!isPhotoMode) return;
            isPhotoMode = false;

            // Restore renderer defaults
            renderer.physicallyCorrectLights = false;
            renderer.toneMapping = THREE.NoToneMapping;
            renderer.toneMappingExposure = 1.0;

            // Restore simple light intensity and color
            directionalLight.intensity = OriginalLook.dirLightIntensity;
            directionalLight.color.setHex(0xffffff);
            directionalLight.position.set(50, 50, 50);

            // Remove photo mode lights (hemisphere and rim light)
            scene.children.forEach((child, index) => {
                if (child.userData && child.userData.isPhotoModeLight) {
                    scene.remove(child);
                }
            });

            // Restore background/fog and remove skybox + sun
            scene.environment = null;
            scene.background = OriginalLook.background || new THREE.Color(0x87ceeb);
            scene.fog = null; // No fog in default mode
            
            // Remove skybox
            if (skyboxMesh) {
                scene.remove(skyboxMesh);
                skyboxMesh.geometry.dispose();
                skyboxMesh.material.dispose();
                skyboxMesh = null;
            }
            
            // Remove cloud layer
            if (cloudPlane) {
                scene.remove(cloudPlane);
                cloudPlane.geometry.dispose();
                cloudPlane.material.map.dispose();
                cloudPlane.material.dispose();
                cloudPlane = null;
                cloudOffset = 0;
            }
            
            // Remove sun disk
            scene.children.forEach(child => {
                if (child.userData && child.userData.isSun) {
                    scene.remove(child);
                    child.geometry.dispose();
                    child.material.dispose();
                }
            });
            
            // Remove hillside and restore original ground
            scene.children.forEach(child => {
                if (child.userData && child.userData.isHillside) {
                    scene.remove(child);
                    child.geometry.dispose();
                    child.material.dispose();
                }
            });
            
            // Ground is always visible now (same terrain in both modes)
            // ground.visible = true; // Already visible

            // Restore original materials
            forEachMesh((m)=>{
                const orig = OriginalMats.get(m);
                if (orig) m.material = orig;
            });

            // Kill post stack
            composer = null; renderPass = null; bloomPass = null; bokehPass = null; fxaaPass = null;
        }
        
        // Update plot data
        function updatePlotData(omega) {
            const targetRadius = turbineParams.radialStation * turbineParams.bladeRadius;
            const bladeLifts = [];
            const bladeMomentsY = [];
            const bladeMomentsZ = [];
            const bladeAoAs = [];
            const bladeVelocities = [];
            const bladeLiftForces = [];
            const bladeTangentialVelocities = [];
            let totalLift = 0;
            let sectionTotalMomentY = 0;  // Section moments (for display at radial station)
            let sectionTotalMomentZ = 0;  // Section moments (for display at radial station)
            
            blades.forEach((blade, bladeIndex) => {
                // Use the azimuth that was stored when thrust was calculated
                const azimuth = blade.userData.currentAzimuth || 0;
                
                // Find segment closest to target radius (for thrust/AoA/velocity traces)
                let closestSegment = null;
                let minDist = Infinity;
                blade.segments.forEach(segment => {
                    const dist = Math.abs(segment.userData.radius - targetRadius);
                    if (dist < minDist) {
                        minDist = dist;
                        closestSegment = segment;
                    }
                });
                
                if (closestSegment) {
                    const thrust = closestSegment.userData.thrust || 0;
                    const aoa = closestSegment.userData.aoa || 0;
                    const velocity = closestSegment.userData.totalVelocity || 0;
                    const liftForce = closestSegment.userData.L || 0;
                    const tangentialVelocity = closestSegment.userData.Vt || 0;
                    bladeLifts.push(thrust);
                    bladeAoAs.push(aoa);
                    bladeVelocities.push(velocity);
                    bladeLiftForces.push(liftForce);
                    bladeTangentialVelocities.push(tangentialVelocity);
                    totalLift += thrust;
                } else {
                    bladeLifts.push(0);
                    bladeAoAs.push(0);
                    bladeVelocities.push(0);
                    bladeLiftForces.push(0);
                    bladeTangentialVelocities.push(0);
                }
                
                // Calculate TOTAL bending moment for this blade (sum over ALL segments)
                // This is the moment that the entire blade creates about the hub in non-rotating frame
                let bladeTotalMomentY = 0;
                let bladeTotalMomentZ = 0;
                
                blade.segments.forEach(segment => {
                    const thrust = segment.userData.thrust || 0;
                    const r = segment.position.y; // Radial distance (moment arm)
                    
                    // Decompose into fixed frame components using the blade azimuth
                    // Coordinate system: X = downwind, Y = horizontal sideways, Z = vertical up
                    // Blade segment position in YZ plane: y = r*cos(œà), z = r*sin(œà)
                    // Thrust force is in +X direction
                    // momentY (nodding, about Y-axis): M_y = F_x * z = thrust * r * sin(œà)
                    // momentZ (yawing, about Z-axis): M_z = -F_x * y = -thrust * r * cos(œà)
                    bladeTotalMomentY += thrust * r * Math.cos(azimuth);  // ‚úÖ NODDING
                    bladeTotalMomentZ += -thrust * r * Math.sin(azimuth); // ‚úÖ YAWING
                });
                
                bladeMomentsY.push(bladeTotalMomentY);
                bladeMomentsZ.push(bladeTotalMomentZ);
                sectionTotalMomentY += bladeTotalMomentY;
                sectionTotalMomentZ += bladeTotalMomentZ;
            });
            
            // Store data with continuous time for scrolling x-axis
            // Increment time value based on rotation speed
            const deltaTime = omega * (2 * Math.PI) / (60 * 60); // radians per frame
            plotData.timeValue += deltaTime;
            
            // Check for TDC crossing (when blade 1 azimuth crosses 0¬∞/360¬∞)
            const blade1Azimuth = blades[0].userData.currentAzimuth || 0;
            const blade1AzimuthDeg = ((blade1Azimuth * 180 / Math.PI) % 360 + 360) % 360;
            
            // Detect TDC crossing by checking if azimuth wrapped around
            // Rotor rotates in negative direction, so check for crossing from 0-10 to 350-360
            if (blades[0].userData.previousAzimuth !== undefined) {
                const prevAzimuth = blades[0].userData.previousAzimuth;
                const prevAzimuthDeg = ((prevAzimuth * 180 / Math.PI) % 360 + 360) % 360;
                // Check if we crossed from 0-10 to 350-360 degrees (negative rotation)
                if (prevAzimuthDeg < 10 && blade1AzimuthDeg > 350) {
                    plotData.tdcMarkers.push(plotData.timeValue);
                }
            }
            blades[0].userData.previousAzimuth = blade1Azimuth;
            
            plotData.time.push(plotData.timeValue.toFixed(3));
            
            // Store raw data (always store the raw values)
            for (let i = 0; i < turbineParams.numBlades; i++) {
                if (plotData.bladeLift[i]) {
                    plotData.bladeLift[i].push(bladeLifts[i] || 0);
                    plotData.bladeMomentY[i].push(bladeMomentsY[i] || 0);
                    plotData.bladeMomentZ[i].push(bladeMomentsZ[i] || 0);
                    plotData.bladeAoA[i].push(bladeAoAs[i] || 0);
                    plotData.bladeVelocity[i].push(bladeVelocities[i] || 0);
                    plotData.bladeLiftForce[i].push(bladeLiftForces[i] || 0);
                    plotData.bladeTangentialVelocity[i].push(bladeTangentialVelocities[i] || 0);
                }
            }
            plotData.totalLift.push(totalLift);
            plotData.totalMomentY.push(turbineParams.currentTotalMomentY || 0);  // Use full rotor moment Y
            plotData.totalMomentZ.push(turbineParams.currentTotalMomentZ || 0);  // Use full rotor moment Z
            plotData.totalThrust.push(turbineParams.currentTotalThrust || 0);
            plotData.totalTorque.push(turbineParams.currentTotalTorque || 0);
            plotData.totalHubMoment.push(turbineParams.currentTotalHubMoment || 0);
            
            // Fourier data collection - collect for exactly one revolution
            if (!turbineParams.paused && omega > 0) {
                // Start collection if not already collecting
                if (!fourierData.collecting && !fourierData.complete) {
                    startFourierCollection();
                }
                
                // Check if we've completed one revolution
                if (fourierData.collecting) {
                    const currentAzimuth = rotorGroup.rotation.x;
                    const angleTraveled = Math.abs(currentAzimuth - fourierData.startAzimuth);  // Use absolute value since rotation is now negative
                    const angleInDegrees = (angleTraveled * 180 / Math.PI) % 360;
                    
                    // Check if enough angular distance has passed since last collection
                    const shouldCollect = (angleInDegrees - fourierData.lastCollectionTime) >= fourierData.samplingInterval;
                    
                    // Store data point at specified sampling interval
                    if (shouldCollect && bladeLifts[0] !== undefined) {
                        fourierData.bladeLift.push(bladeLifts[0]);
                        fourierData.bladeMomentY.push(bladeMomentsY[0]);
                        fourierData.bladeMomentZ.push(bladeMomentsZ[0]);
                        fourierData.bladeAoA.push(bladeAoAs[0]);
                        fourierData.bladeVelocity.push(bladeVelocities[0]);
                        fourierData.bladeLiftForce.push(bladeLiftForces[0]);
                        fourierData.bladeTangentialVelocity.push(bladeTangentialVelocities[0]);
                        fourierData.totalLift.push(totalLift);
                        fourierData.totalMomentY.push(turbineParams.currentTotalMomentY || 0);  // Use full rotor moment Y
                        fourierData.totalMomentZ.push(turbineParams.currentTotalMomentZ || 0);  // Use full rotor moment Z
                        fourierData.totalThrust.push(turbineParams.currentTotalThrust || 0);
                        fourierData.totalTorque.push(turbineParams.currentTotalTorque || 0);
                        fourierData.totalHubMoment.push(turbineParams.currentTotalHubMoment || 0);
                        fourierData.lastCollectionTime = angleInDegrees;
                    }
                    
                    // Check if we've completed one full revolution (2œÄ radians)
                    if (angleTraveled >= 2 * Math.PI) {
                        fourierData.collecting = false;
                        fourierData.complete = true;
                        fourierData.everCompleted = true;  // Mark that we've had valid data at least once
                        
                        // Update Fourier display immediately with completed data
                        updateFourierDisplay();
                        
                        // After first fast collection, switch to normal mode for subsequent collections
                        if (fourierData.fastMode) {
                            fourierData.fastMode = false;
                            // Clear all trace data after fast collection completes
                            initPlotData();
                            updateCharts();
                        }
                        
                        // Automatically restart collection for next revolution
                        // This keeps the Fourier analysis up-to-date as loads change with every revolution
                        setTimeout(() => {
                            resetFourierCollection();
                            // Don't re-enable fast mode - keep it at normal speed
                            fourierData.fastMode = false;
                            startFourierCollection();
                        }, 100); // Small delay to ensure display updates
                    }
                }
            }
            
            // Limit data to exactly 2 revolutions (720¬∞)
            // Calculate max points based on angular resolution
            const degreesPerRevolution = 360;
            const maxRevolutions = 2;
            const maxDataPoints = Math.ceil((degreesPerRevolution * maxRevolutions) / turbineParams.angularResolution);
            
            // Once we have max points, start removing from the left (scrolling)
            if (plotData.time.length > maxDataPoints) {
                plotData.time.shift();
                plotData.bladeLift.forEach(arr => arr.shift());
                plotData.bladeMomentY.forEach(arr => arr.shift());
                plotData.bladeMomentZ.forEach(arr => arr.shift());
                plotData.bladeAoA.forEach(arr => arr.shift());
                plotData.bladeVelocity.forEach(arr => arr.shift());
                plotData.totalLift.shift();
                plotData.totalMomentY.shift();
                plotData.totalMomentZ.shift();
                plotData.totalThrust.shift();
                plotData.totalTorque.shift();
                plotData.totalHubMoment.shift();
                
                // Keep only the 2 most recent TDC markers
                if (plotData.tdcMarkers.length > 2) {
                    plotData.tdcMarkers.shift();
                }
            }
            
            // Safety check: hard limit to prevent memory issues
            const absoluteMaxPoints = 5000; // Emergency brake
            if (plotData.time.length > absoluteMaxPoints) {
                console.warn('Data array exceeded safety limit, clearing oldest data');
                const excessPoints = plotData.time.length - maxDataPoints;
                for (let i = 0; i < excessPoints; i++) {
                    plotData.time.shift();
                    plotData.bladeLift.forEach(arr => arr.shift());
                    plotData.bladeMomentY.forEach(arr => arr.shift());
                    plotData.bladeMomentZ.forEach(arr => arr.shift());
                    plotData.bladeAoA.forEach(arr => arr.shift());
                    plotData.bladeVelocity.forEach(arr => arr.shift());
                    plotData.totalLift.shift();
                    plotData.totalMomentY.shift();
                    plotData.totalMomentZ.shift();
                    plotData.totalThrust.shift();
                    plotData.totalTorque.shift();
                    plotData.totalHubMoment.shift();
                }
            }
            
            // Update charts
            updateCharts();
            
            // Update spanwise display (update less frequently for performance)
            if (frameCount % 3 === 0) { // Update spanwise every 3 frames (20 times per second at 60fps)
                updateSpanwiseChart();
            }
            // Section diagram is now updated immediately after blade loads in updateBladeLoads()
        }
        
        // Update chart displays
        function updateCharts() {
            if (plotData.bladeLift.length !== turbineParams.numBlades) {
                // Data arrays don't match blade count, skip update
                return;
            }
            
            // Prepare data for display (with optional mean removal)
            let displayBladeLift = plotData.bladeLift;
            let displayBladeMomentY = plotData.bladeMomentY;
            let displayBladeMomentZ = plotData.bladeMomentZ;
            let displayBladeAoA = plotData.bladeAoA;
            let displayBladeVelocity = plotData.bladeVelocity;
            let displayTotalLift = plotData.totalLift;
            let displayTotalMomentY = plotData.totalMomentY;
            let displayTotalMomentZ = plotData.totalMomentZ;
            
            if (turbineParams.removeMean) {
                // Calculate and subtract mean from each dataset
                displayBladeLift = plotData.bladeLift.map(bladeData => {
                    if (bladeData && bladeData.length > 0) {
                        const mean = bladeData.reduce((a, b) => a + b, 0) / bladeData.length;
                        return bladeData.map(v => v - mean);
                    }
                    return bladeData;
                });
                
                displayBladeMomentY = plotData.bladeMomentY.map(bladeData => {
                    if (bladeData && bladeData.length > 0) {
                        const mean = bladeData.reduce((a, b) => a + b, 0) / bladeData.length;
                        return bladeData.map(v => v - mean);
                    }
                    return bladeData;
                });
                
                displayBladeMomentZ = plotData.bladeMomentZ.map(bladeData => {
                    if (bladeData && bladeData.length > 0) {
                        const mean = bladeData.reduce((a, b) => a + b, 0) / bladeData.length;
                        return bladeData.map(v => v - mean);
                    }
                    return bladeData;
                });
                
                displayBladeAoA = plotData.bladeAoA.map(bladeData => {
                    if (bladeData && bladeData.length > 0) {
                        const mean = bladeData.reduce((a, b) => a + b, 0) / bladeData.length;
                        return bladeData.map(v => v - mean);
                    }
                    return bladeData;
                });
                
                displayBladeVelocity = plotData.bladeVelocity.map(bladeData => {
                    if (bladeData && bladeData.length > 0) {
                        const mean = bladeData.reduce((a, b) => a + b, 0) / bladeData.length;
                        return bladeData.map(v => v - mean);
                    }
                    return bladeData;
                });
                
                // Remove mean from totals
                if (plotData.totalLift.length > 0) {
                    const meanLift = plotData.totalLift.reduce((a, b) => a + b, 0) / plotData.totalLift.length;
                    displayTotalLift = plotData.totalLift.map(v => v - meanLift);
                }
                
                if (plotData.totalMomentY.length > 0) {
                    const meanMomentY = plotData.totalMomentY.reduce((a, b) => a + b, 0) / plotData.totalMomentY.length;
                    displayTotalMomentY = plotData.totalMomentY.map(v => v - meanMomentY);
                }
                
                if (plotData.totalMomentZ.length > 0) {
                    const meanMomentZ = plotData.totalMomentZ.reduce((a, b) => a + b, 0) / plotData.totalMomentZ.length;
                    displayTotalMomentZ = plotData.totalMomentZ.map(v => v - meanMomentZ);
                }
            }
            
            // Calculate dynamic x-axis bounds based on current data
            let xMin = 0;
            let xMax = 4 * Math.PI; // Default to 4œÄ (720¬∞)
            
            if (plotData.time.length > 0) {
                const firstTime = parseFloat(plotData.time[0]);
                const lastTime = parseFloat(plotData.time[plotData.time.length - 1]);
                
                // If we haven't filled the buffer yet, show from 0 to current max (clipped to 4œÄ)
                const maxDataPoints = Math.ceil((360 * 2) / turbineParams.angularResolution);
                if (plotData.time.length < maxDataPoints) {
                    xMin = 0;
                    xMax = Math.min(lastTime, 4 * Math.PI); // Clip to data or 4œÄ, whichever is smaller
                } else {
                    // Once full, scroll with the data
                    xMin = firstTime;
                    xMax = lastTime;
                }
            }
            
            // Get current azimuth for position indicator
            const currentAzimuthDeg = ((rotorGroup.rotation.x * 180 / Math.PI) % 360);
            const normalizedCurrentAzimuth = currentAzimuthDeg >= 0 ? currentAzimuthDeg : currentAzimuthDeg + 360;
            
            // Update lift chart
            liftChart.data.labels = plotData.time;
            liftChart.options.scales.x.min = xMin;
            liftChart.options.scales.x.max = xMax;
            for (let i = 0; i < turbineParams.numBlades; i++) {
                if (liftChart.data.datasets[i] && displayBladeLift[i]) {
                    liftChart.data.datasets[i].data = displayBladeLift[i];
                }
            }
            if (liftChart.data.datasets[turbineParams.numBlades]) {
                liftChart.data.datasets[turbineParams.numBlades].data = displayTotalLift;
            }
            // Store current azimuth for drawing indicator
            liftChart.currentAzimuth = turbineParams.paused ? normalizedCurrentAzimuth : null;
            liftChart.update('none');
            
            // Update moment Y chart (nodding)
            momentYChart.data.labels = plotData.time;
            momentYChart.options.scales.x.min = xMin;
            momentYChart.options.scales.x.max = xMax;
            for (let i = 0; i < turbineParams.numBlades; i++) {
                if (momentYChart.data.datasets[i] && displayBladeMomentZ[i]) {
                    momentYChart.data.datasets[i].data = displayBladeMomentZ[i];  // Y chart shows Z data (yawing)
                }
            }
            if (momentYChart.data.datasets[turbineParams.numBlades]) {
                momentYChart.data.datasets[turbineParams.numBlades].data = displayTotalMomentZ;  // Y chart shows Z data (yawing)
            }
            momentYChart.currentAzimuth = turbineParams.paused ? normalizedCurrentAzimuth : null;
            momentYChart.update('none');
            
            // Update moment Z chart (nodding)
            momentZChart.data.labels = plotData.time;
            momentZChart.options.scales.x.min = xMin;
            momentZChart.options.scales.x.max = xMax;
            for (let i = 0; i < turbineParams.numBlades; i++) {
                if (momentZChart.data.datasets[i] && displayBladeMomentY[i]) {
                    momentZChart.data.datasets[i].data = displayBladeMomentY[i];  // Z chart shows Y data (nodding)
                }
            }
            if (momentZChart.data.datasets[turbineParams.numBlades]) {
                momentZChart.data.datasets[turbineParams.numBlades].data = displayTotalMomentY;  // Z chart shows Y data (nodding)
            }
            momentZChart.currentAzimuth = turbineParams.paused ? normalizedCurrentAzimuth : null;
            momentZChart.update('none');
            
            // Update AoA chart (no total)
            aoaChart.data.labels = plotData.time;
            aoaChart.options.scales.x.min = xMin;
            aoaChart.options.scales.x.max = xMax;
            for (let i = 0; i < turbineParams.numBlades; i++) {
                if (aoaChart.data.datasets[i] && displayBladeAoA[i]) {
                    aoaChart.data.datasets[i].data = displayBladeAoA[i];
                }
            }
            aoaChart.currentAzimuth = turbineParams.paused ? normalizedCurrentAzimuth : null;
            aoaChart.update('none');
            
            // Update Velocity chart (no total)
            velocityChart.data.labels = plotData.time;
            velocityChart.options.scales.x.min = xMin;
            velocityChart.options.scales.x.max = xMax;
            for (let i = 0; i < turbineParams.numBlades; i++) {
                if (velocityChart.data.datasets[i] && displayBladeVelocity[i]) {
                    velocityChart.data.datasets[i].data = displayBladeVelocity[i];
                }
            }
            velocityChart.currentAzimuth = turbineParams.paused ? normalizedCurrentAzimuth : null;
            velocityChart.update('none');
            
            // Update Lift Force chart (no total)
            liftForceChart.data.labels = plotData.time;
            liftForceChart.options.scales.x.min = xMin;
            liftForceChart.options.scales.x.max = xMax;
            for (let i = 0; i < turbineParams.numBlades; i++) {
                if (liftForceChart.data.datasets[i] && plotData.bladeLiftForce[i]) {
                    liftForceChart.data.datasets[i].data = plotData.bladeLiftForce[i];
                }
            }
            liftForceChart.currentAzimuth = turbineParams.paused ? normalizedCurrentAzimuth : null;
            liftForceChart.update('none');
            
            
            // Update Fourier analysis if we have enough data
            updateFourierDisplay();
        }
        
        // Update Fourier analysis display
        function updateFourierDisplay() {
            const thrustContent = document.getElementById('fourier-thrust-content');
            const momentYContent = document.getElementById('fourier-moment-y-content');
            const momentZContent = document.getElementById('fourier-moment-z-content');
            const aoaContent = document.getElementById('fourier-aoa-content');
            const velocityContent = document.getElementById('fourier-velocity-content');
            const liftContent = document.getElementById('fourier-lift-content');
            
            // Check if elements exist (they might not if we're still loading)
            if (!thrustContent || !momentYContent || !momentZContent || !aoaContent || !velocityContent || !liftContent) return;
            
            // Check collection status
            if (fourierData.collecting) {
                // While collecting, keep showing old values without updating
                // Don't recalculate or flash the numbers during collection
                if (fourierData.everCompleted) {
                    // Already have data from a previous collection, keep displaying it unchanged
                    return;
                } else {
                    // First time collecting, show status message
                const mode = fourierData.fastMode ? ' (fast ' + fourierData.speedMultiplier + 'x)' : '';
                const statusMsg = '<p style="font-size: 0.85em; color: #999;">Collecting... (' + fourierData.bladeLift.length + ' pts)</p>';
                    thrustContent.innerHTML = statusMsg;
                    momentYContent.innerHTML = statusMsg;
                    momentZContent.innerHTML = statusMsg;
                    aoaContent.innerHTML = statusMsg;
                    velocityContent.innerHTML = statusMsg;
                    liftContent.innerHTML = statusMsg;
                return;
                }
            }
            
            if (!fourierData.everCompleted || fourierData.bladeLift.length < 10) {
                const waitMsg = '<p style="font-size: 0.85em; color: #999;">Waiting...</p>';
                thrustContent.innerHTML = waitMsg;
                momentYContent.innerHTML = waitMsg;
                momentZContent.innerHTML = waitMsg;
                aoaContent.innerHTML = waitMsg;
                velocityContent.innerHTML = waitMsg;
                liftContent.innerHTML = waitMsg;
                return;
            }
            
            // Use collected Fourier data
            const blade1Thrust = fourierData.bladeLift;
            const blade1MomentY = fourierData.bladeMomentY;
            const blade1MomentZ = fourierData.bladeMomentZ;
            const totalThrust = fourierData.totalLift;
            const totalMomentY = fourierData.totalMomentY;
            const totalMomentZ = fourierData.totalMomentZ;
            
            // Perform Fourier analysis (up to 2B, where B = numBlades, minimum 3P)
            const maxHarmonic = Math.max(3, 2 * turbineParams.numBlades);
            const blade1ThrustFourier = analyzeFourier(blade1Thrust, maxHarmonic);
            const blade1MomentYFourier = analyzeFourier(blade1MomentY, maxHarmonic);
            const blade1MomentZFourier = analyzeFourier(blade1MomentZ, maxHarmonic);
            const totalThrustFourier = analyzeFourier(totalThrust, maxHarmonic);
            const totalMomentYFourier = analyzeFourier(totalMomentY, maxHarmonic);
            const totalMomentZFourier = analyzeFourier(totalMomentZ, maxHarmonic);
            
            // Calculate percentages of total
            function calculatePercent(fourier) {
                const totalAmplitude = fourier.reduce((sum, h) => sum + Math.abs(h.amplitude), 0);
                return fourier.map(h => ({
                    ...h,
                    percent: totalAmplitude > 0 ? (Math.abs(h.amplitude) / totalAmplitude * 100) : 0
                }));
            }
            
            const blade1ThrustWithPercent = calculatePercent(blade1ThrustFourier);
            const totalThrustWithPercent = calculatePercent(totalThrustFourier);
            const blade1MomentYWithPercent = calculatePercent(blade1MomentYFourier);
            const blade1MomentZWithPercent = calculatePercent(blade1MomentZFourier);
            const totalMomentYWithPercent = calculatePercent(totalMomentYFourier);
            const totalMomentZWithPercent = calculatePercent(totalMomentZFourier);
            
            // Build HTML for each tab separately
            
            // Helper function to create Fourier series equation
            function createFourierEquation(label, fourier) {
                const A0 = fourier.find(h => h.harmonic === 0);
                const harmonics = fourier.filter(h => h.harmonic > 0);
                
                let eq = `<div style="background: #f0f0f0; padding: 8px; margin: 5px 0; border-radius: 4px; font-family: 'Courier New', monospace; font-size: 0.85em; overflow-x: auto;">`;
                eq += `<strong>${label} =</strong> `;
                
                if (A0) {
                    eq += `${A0.amplitude.toFixed(2)}`;
                } else {
                    eq += `0`;
                }
                
                harmonics.forEach((h, idx) => {
                    const sign = h.amplitude >= 0 ? ' + ' : ' - ';
                    const absAmp = Math.abs(h.amplitude).toFixed(2);
                    eq += `${sign}${absAmp}¬∑sin(${h.harmonic}œà)`;
                });
                
                eq += `</div>`;
                return eq;
            }
            
            // === THRUST TAB ===
            let thrustHtml = '';
            
            // Blade 1 Thrust
            thrustHtml += '<h5 style="margin: 10px 0 5px 0; font-size: 0.95em;">Blade 1 Thrust (rotating/blade frame)</h5>';
            thrustHtml += createFourierEquation('T', blade1ThrustFourier);
            thrustHtml += '<table style="width: 100%; font-size: 0.8em; border-collapse: collapse;">';
            thrustHtml += '<thead><tr style="background: #ddd;">';
            thrustHtml += '<th style="padding: 3px; text-align: center;">nP</th>';
            thrustHtml += '<th style="padding: 3px; text-align: right;">Amp</th>';
            thrustHtml += '<th style="padding: 3px; text-align: right;">%</th>';
            thrustHtml += '</tr></thead><tbody>';
            blade1ThrustWithPercent.forEach((h, idx) => {
                thrustHtml += `<tr style="background: ${idx % 2 === 0 ? '#f9f9f9' : '#fff'};">`;
                thrustHtml += `<td style="padding: 3px; text-align: center;">${h.harmonic}P</td>`;
                thrustHtml += `<td style="padding: 3px; text-align: right;">${h.amplitude.toFixed(2)}</td>`;
                thrustHtml += `<td style="padding: 3px; text-align: right;">${h.percent.toFixed(1)}%</td>`;
                thrustHtml += '</tr>';
            });
            thrustHtml += '</tbody></table>';
            
            // Total Rotor Thrust
            thrustHtml += '<h5 style="margin: 15px 0 5px 0; font-size: 0.95em;">Total Rotor Thrust (non-rotating frame)</h5>';
            thrustHtml += createFourierEquation('T_total', totalThrustFourier);
            thrustHtml += '<table style="width: 100%; font-size: 0.8em; border-collapse: collapse;">';
            thrustHtml += '<thead><tr style="background: #ddd;">';
            thrustHtml += '<th style="padding: 3px; text-align: center;">nP</th>';
            thrustHtml += '<th style="padding: 3px; text-align: right;">Amp</th>';
            thrustHtml += '<th style="padding: 3px; text-align: right;">%</th>';
            thrustHtml += '</tr></thead><tbody>';
            totalThrustWithPercent.forEach((h, idx) => {
                thrustHtml += `<tr style="background: ${idx % 2 === 0 ? '#f9f9f9' : '#fff'};">`;
                thrustHtml += `<td style="padding: 3px; text-align: center;">${h.harmonic}P</td>`;
                thrustHtml += `<td style="padding: 3px; text-align: right;">${h.amplitude.toFixed(2)}</td>`;
                thrustHtml += `<td style="padding: 3px; text-align: right;">${h.percent.toFixed(1)}%</td>`;
                thrustHtml += '</tr>';
            });
            thrustHtml += '</tbody></table>';
            
            // === MOMENT Y TAB === (Shows YAWING, which is Z data)
            let momentYHtml = '';
            
            // Blade 1 Yawing Moment
            momentYHtml += '<h5 style="margin: 10px 0 5px 0; font-size: 0.95em;">Blade 1 Yawing (rotating/blade frame)</h5>';
            momentYHtml += createFourierEquation('M_z', blade1MomentZFourier);
            momentYHtml += '<table style="width: 100%; font-size: 0.8em; border-collapse: collapse;">';
            momentYHtml += '<thead><tr style="background: #ddd;">';
            momentYHtml += '<th style="padding: 3px; text-align: center;">nP</th>';
            momentYHtml += '<th style="padding: 3px; text-align: right;">Amp</th>';
            momentYHtml += '<th style="padding: 3px; text-align: right;">%</th>';
            momentYHtml += '</tr></thead><tbody>';
            blade1MomentZWithPercent.forEach((h, idx) => {
                momentYHtml += `<tr style="background: ${idx % 2 === 0 ? '#f9f9f9' : '#fff'};">`;
                momentYHtml += `<td style="padding: 3px; text-align: center;">${h.harmonic}P</td>`;
                momentYHtml += `<td style="padding: 3px; text-align: right;">${h.amplitude.toFixed(2)}</td>`;
                momentYHtml += `<td style="padding: 3px; text-align: right;">${h.percent.toFixed(1)}%</td>`;
                momentYHtml += '</tr>';
            });
            momentYHtml += '</tbody></table>';
            
            // Total Rotor Yawing Moment
            momentYHtml += '<h5 style="margin: 15px 0 5px 0; font-size: 0.95em;">Total Rotor Yawing (non-rotating frame)</h5>';
            momentYHtml += createFourierEquation('M_z,total', totalMomentZFourier);
            momentYHtml += '<table style="width: 100%; font-size: 0.8em; border-collapse: collapse;">';
            momentYHtml += '<thead><tr style="background: #ddd;">';
            momentYHtml += '<th style="padding: 3px; text-align: center;">nP</th>';
            momentYHtml += '<th style="padding: 3px; text-align: right;">Amp</th>';
            momentYHtml += '<th style="padding: 3px; text-align: right;">%</th>';
            momentYHtml += '</tr></thead><tbody>';
            totalMomentZWithPercent.forEach((h, idx) => {
                momentYHtml += `<tr style="background: ${idx % 2 === 0 ? '#f9f9f9' : '#fff'};">`;
                momentYHtml += `<td style="padding: 3px; text-align: center;">${h.harmonic}P</td>`;
                momentYHtml += `<td style="padding: 3px; text-align: right;">${h.amplitude.toFixed(2)}</td>`;
                momentYHtml += `<td style="padding: 3px; text-align: right;">${h.percent.toFixed(1)}%</td>`;
                momentYHtml += '</tr>';
            });
            momentYHtml += '</tbody></table>';
            
            // === MOMENT Z TAB === (Shows NODDING, which is Y data)
            let momentZHtml = '';
            
            // Blade 1 Nodding Moment
            momentZHtml += '<h5 style="margin: 10px 0 5px 0; font-size: 0.95em;">Blade 1 Nodding (rotating/blade frame)</h5>';
            momentZHtml += createFourierEquation('M_y', blade1MomentYFourier);
            momentZHtml += '<table style="width: 100%; font-size: 0.8em; border-collapse: collapse;">';
            momentZHtml += '<thead><tr style="background: #ddd;">';
            momentZHtml += '<th style="padding: 3px; text-align: center;">nP</th>';
            momentZHtml += '<th style="padding: 3px; text-align: right;">Amp</th>';
            momentZHtml += '<th style="padding: 3px; text-align: right;">%</th>';
            momentZHtml += '</tr></thead><tbody>';
            blade1MomentYWithPercent.forEach((h, idx) => {
                momentZHtml += `<tr style="background: ${idx % 2 === 0 ? '#f9f9f9' : '#fff'};">`;
                momentZHtml += `<td style="padding: 3px; text-align: center;">${h.harmonic}P</td>`;
                momentZHtml += `<td style="padding: 3px; text-align: right;">${h.amplitude.toFixed(2)}</td>`;
                momentZHtml += `<td style="padding: 3px; text-align: right;">${h.percent.toFixed(1)}%</td>`;
                momentZHtml += '</tr>';
            });
            momentZHtml += '</tbody></table>';
            
            // Total Rotor Nodding Moment
            momentZHtml += '<h5 style="margin: 15px 0 5px 0; font-size: 0.95em;">Total Rotor Nodding (non-rotating frame)</h5>';
            momentZHtml += createFourierEquation('M_y,total', totalMomentYFourier);
            momentZHtml += '<table style="width: 100%; font-size: 0.8em; border-collapse: collapse;">';
            momentZHtml += '<thead><tr style="background: #ddd;">';
            momentZHtml += '<th style="padding: 3px; text-align: center;">nP</th>';
            momentZHtml += '<th style="padding: 3px; text-align: right;">Amp</th>';
            momentZHtml += '<th style="padding: 3px; text-align: right;">%</th>';
            momentZHtml += '</tr></thead><tbody>';
            totalMomentYWithPercent.forEach((h, idx) => {
                momentZHtml += `<tr style="background: ${idx % 2 === 0 ? '#f9f9f9' : '#fff'};">`;
                momentZHtml += `<td style="padding: 3px; text-align: center;">${h.harmonic}P</td>`;
                momentZHtml += `<td style="padding: 3px; text-align: right;">${h.amplitude.toFixed(2)}</td>`;
                momentZHtml += `<td style="padding: 3px; text-align: right;">${h.percent.toFixed(1)}%</td>`;
                momentZHtml += '</tr>';
            });
            momentZHtml += '</tbody></table>';
            
            thrustContent.innerHTML = thrustHtml;
            momentYContent.innerHTML = momentYHtml;
            momentZContent.innerHTML = momentZHtml;
            
            // === AOA TAB === (Blade data only, no total)
            const blade1AoA = fourierData.bladeAoA;
            const blade1AoAFourier = analyzeFourier(blade1AoA, maxHarmonic);
            const blade1AoAWithPercent = calculatePercent(blade1AoAFourier);
            
            let aoaHtml = '';
            aoaHtml += '<h5 style="margin: 10px 0 5px 0; font-size: 0.95em;">Blade 1 Angle of Attack (rotating/blade frame)</h5>';
            aoaHtml += createFourierEquation('AoA', blade1AoAFourier);
            aoaHtml += '<table style="width: 100%; font-size: 0.8em; border-collapse: collapse;">';
            aoaHtml += '<thead><tr style="background: #ddd;">';
            aoaHtml += '<th style="padding: 3px; text-align: center;">nP</th>';
            aoaHtml += '<th style="padding: 3px; text-align: right;">Amp (deg)</th>';
            aoaHtml += '<th style="padding: 3px; text-align: right;">%</th>';
            aoaHtml += '</tr></thead><tbody>';
            blade1AoAWithPercent.forEach((h, idx) => {
                aoaHtml += `<tr style="background: ${idx % 2 === 0 ? '#f9f9f9' : '#fff'};">`;
                aoaHtml += `<td style="padding: 3px; text-align: center;">${h.harmonic}P</td>`;
                aoaHtml += `<td style="padding: 3px; text-align: right;">${h.amplitude.toFixed(2)}</td>`;
                aoaHtml += `<td style="padding: 3px; text-align: right;">${h.percent.toFixed(1)}%</td>`;
                aoaHtml += '</tr>';
            });
            aoaHtml += '</tbody></table>';
            aoaContent.innerHTML = aoaHtml;
            
            // === VELOCITY TAB === (Blade data only, no total)
            const blade1Velocity = fourierData.bladeVelocity;
            const blade1VelocityFourier = analyzeFourier(blade1Velocity, maxHarmonic);
            const blade1VelocityWithPercent = calculatePercent(blade1VelocityFourier);
            
            let velocityHtml = '';
            velocityHtml += '<h5 style="margin: 10px 0 5px 0; font-size: 0.95em;">Blade 1 Total Velocity (rotating/blade frame)</h5>';
            velocityHtml += createFourierEquation('V', blade1VelocityFourier);
            velocityHtml += '<table style="width: 100%; font-size: 0.8em; border-collapse: collapse;">';
            velocityHtml += '<thead><tr style="background: #ddd;">';
            velocityHtml += '<th style="padding: 3px; text-align: center;">nP</th>';
            velocityHtml += '<th style="padding: 3px; text-align: right;">Amp (m/s)</th>';
            velocityHtml += '<th style="padding: 3px; text-align: right;">%</th>';
            velocityHtml += '</tr></thead><tbody>';
            blade1VelocityWithPercent.forEach((h, idx) => {
                velocityHtml += `<tr style="background: ${idx % 2 === 0 ? '#f9f9f9' : '#fff'};">`;
                velocityHtml += `<td style="padding: 3px; text-align: center;">${h.harmonic}P</td>`;
                velocityHtml += `<td style="padding: 3px; text-align: right;">${h.amplitude.toFixed(2)}</td>`;
                velocityHtml += `<td style="padding: 3px; text-align: right;">${h.percent.toFixed(1)}%</td>`;
                velocityHtml += '</tr>';
            });
            velocityHtml += '</tbody></table>';
            velocityContent.innerHTML = velocityHtml;
            
            // === LIFT FORCE TAB === (Blade data only, no total)
            const blade1LiftForce = fourierData.bladeLiftForce;
            const blade1LiftForceFourier = analyzeFourier(blade1LiftForce, maxHarmonic);
            const blade1LiftForceWithPercent = calculatePercent(blade1LiftForceFourier);
            
            let liftHtml = '';
            liftHtml += '<h5 style="margin: 10px 0 5px 0; font-size: 0.95em;">Blade 1 Lift Force (rotating/blade frame)</h5>';
            liftHtml += createFourierEquation('L', blade1LiftForceFourier);
            liftHtml += '<table style="width: 100%; font-size: 0.8em; border-collapse: collapse;">';
            liftHtml += '<thead><tr style="background: #ddd;">';
            liftHtml += '<th style="padding: 3px; text-align: center;">nP</th>';
            liftHtml += '<th style="padding: 3px; text-align: right;">Amp (N)</th>';
            liftHtml += '<th style="padding: 3px; text-align: right;">%</th>';
            liftHtml += '</tr></thead><tbody>';
            blade1LiftForceWithPercent.forEach((h, idx) => {
                liftHtml += `<tr style="background: ${idx % 2 === 0 ? '#f9f9f9' : '#fff'};">`;
                liftHtml += `<td style="padding: 3px; text-align: center;">${h.harmonic}P</td>`;
                liftHtml += `<td style="padding: 3px; text-align: right;">${h.amplitude.toFixed(2)}</td>`;
                liftHtml += `<td style="padding: 3px; text-align: right;">${h.percent.toFixed(1)}%</td>`;
                liftHtml += '</tr>';
            });
            liftHtml += '</tbody></table>';
            liftContent.innerHTML = liftHtml;
            
            // === TOTAL LOADS FOURIER ANALYSIS ===
            const totalThrustContent = document.getElementById('fourier-total-thrust-content');
            const totalTorqueContent = document.getElementById('fourier-total-torque-content');
            const noddingMomentContent = document.getElementById('fourier-nodding-moment-content');
            const yawingMomentContent = document.getElementById('fourier-yawing-moment-content');
            
            if (totalThrustContent && totalTorqueContent && noddingMomentContent && yawingMomentContent) {
                // Analyze total rotor loads
                const totalRotorThrust = fourierData.totalThrust;
                const totalRotorTorque = fourierData.totalTorque;
                const totalRotorNoddingMoment = fourierData.totalMomentY;  // Use My (nodding)
                const totalRotorYawingMoment = fourierData.totalMomentZ;  // Use Mz (yawing)
                
                const totalRotorThrustFourier = analyzeFourier(totalRotorThrust, maxHarmonic);
                const totalRotorTorqueFourier = analyzeFourier(totalRotorTorque, maxHarmonic);
                const totalRotorNoddingMomentFourier = analyzeFourier(totalRotorNoddingMoment, maxHarmonic);
                const totalRotorYawingMomentFourier = analyzeFourier(totalRotorYawingMoment, maxHarmonic);
                
                const totalRotorThrustWithPercent = calculatePercent(totalRotorThrustFourier);
                const totalRotorTorqueWithPercent = calculatePercent(totalRotorTorqueFourier);
                const totalRotorNoddingMomentWithPercent = calculatePercent(totalRotorNoddingMomentFourier);
                const totalRotorYawingMomentWithPercent = calculatePercent(totalRotorYawingMomentFourier);
                
                // Total Thrust
                let totalThrustHtml = createFourierEquation('Total Thrust', totalRotorThrustFourier);
                totalThrustHtml += `<div style="margin-top: 10px;">`;
                totalRotorThrustWithPercent.forEach(h => {
                    const pLabel = h.harmonic === 0 ? 'Mean (0P)' : `${h.harmonic}P`;
                    totalThrustHtml += `<div style="display: flex; justify-content: space-between; margin: 3px 0; font-size: 0.85em;">`;
                    totalThrustHtml += `<span><strong>${pLabel}:</strong> ${h.amplitude.toFixed(2)} N</span>`;
                    totalThrustHtml += `<span style="color: #999;">(${h.percent.toFixed(1)}%)</span>`;
                    totalThrustHtml += `</div>`;
                });
                totalThrustHtml += `</div>`;
                totalThrustContent.innerHTML = totalThrustHtml;
                
                // Total Torque
                let totalTorqueHtml = createFourierEquation('Total Torque', totalRotorTorqueFourier);
                totalTorqueHtml += `<div style="margin-top: 10px;">`;
                totalRotorTorqueWithPercent.forEach(h => {
                    const pLabel = h.harmonic === 0 ? 'Mean (0P)' : `${h.harmonic}P`;
                    totalTorqueHtml += `<div style="display: flex; justify-content: space-between; margin: 3px 0; font-size: 0.85em;">`;
                    totalTorqueHtml += `<span><strong>${pLabel}:</strong> ${h.amplitude.toFixed(2)} N‚ãÖm</span>`;
                    totalTorqueHtml += `<span style="color: #999;">(${h.percent.toFixed(1)}%)</span>`;
                    totalTorqueHtml += `</div>`;
                });
                totalTorqueHtml += `</div>`;
                totalTorqueContent.innerHTML = totalTorqueHtml;
                
                // Nodding Moment
                let noddingMomentHtml = createFourierEquation('Nodding Moment', totalRotorNoddingMomentFourier);
                noddingMomentHtml += `<div style="margin-top: 10px;">`;
                totalRotorNoddingMomentWithPercent.forEach(h => {
                    const pLabel = h.harmonic === 0 ? 'Mean (0P)' : `${h.harmonic}P`;
                    noddingMomentHtml += `<div style="display: flex; justify-content: space-between; margin: 3px 0; font-size: 0.85em;">`;
                    noddingMomentHtml += `<span><strong>${pLabel}:</strong> ${h.amplitude.toFixed(2)} N‚ãÖm</span>`;
                    noddingMomentHtml += `<span style="color: #999;">(${h.percent.toFixed(1)}%)</span>`;
                    noddingMomentHtml += `</div>`;
                });
                noddingMomentHtml += `</div>`;
                noddingMomentContent.innerHTML = noddingMomentHtml;
                
                // Yawing Moment
                let yawingMomentHtml = createFourierEquation('Yawing Moment', totalRotorYawingMomentFourier);
                yawingMomentHtml += `<div style="margin-top: 10px;">`;
                totalRotorYawingMomentWithPercent.forEach(h => {
                    const pLabel = h.harmonic === 0 ? 'Mean (0P)' : `${h.harmonic}P`;
                    yawingMomentHtml += `<div style="display: flex; justify-content: space-between; margin: 3px 0; font-size: 0.85em;">`;
                    yawingMomentHtml += `<span><strong>${pLabel}:</strong> ${h.amplitude.toFixed(2)} N‚ãÖm</span>`;
                    yawingMomentHtml += `<span style="color: #999;">(${h.percent.toFixed(1)}%)</span>`;
                    yawingMomentHtml += `</div>`;
                });
                yawingMomentHtml += `</div>`;
                yawingMomentContent.innerHTML = yawingMomentHtml;
            }
        }
        
        // Rebuild charts when blade count changes
        function rebuildCharts() {
            // Don't rebuild if charts haven't been initialized yet
            try {
                if (!liftChart) return;
            } catch (e) {
                return;
            }
            
            chartDatasets = createChartDatasets();
            
            // Completely rebuild lift chart
            liftChart.data.datasets = chartDatasets.liftDatasets;
            liftChart.data.labels = [];
            liftChart.update('reset');
            
            // Completely rebuild moment Y chart
            momentYChart.data.datasets = chartDatasets.momentYDatasets;
            momentYChart.data.labels = [];
            momentYChart.update('reset');
            
            // Completely rebuild moment Z chart
            momentZChart.data.datasets = chartDatasets.momentZDatasets;
            momentZChart.data.labels = [];
            momentZChart.update('reset');
            
            // Completely rebuild AoA chart
            aoaChart.data.datasets = chartDatasets.aoaDatasets;
            aoaChart.data.labels = [];
            aoaChart.update('reset');
            
            // Completely rebuild Velocity chart
            velocityChart.data.datasets = chartDatasets.velocityDatasets;
            velocityChart.data.labels = [];
            velocityChart.update('reset');
            
            // Completely rebuild Lift Force chart
            liftForceChart.data.datasets = chartDatasets.liftForceDatasets;
            liftForceChart.data.labels = [];
            liftForceChart.update('reset');
            
            
            // Rebuild Total Load charts (only if they exist)
            try {
                if (thrustRotatingChart) {
                    rebuildTotalLoadCharts();
                }
            } catch (e) {
                // Charts not initialized yet
            }
        }
        
        // Create chart datasets
        function createChartDatasets() {
            const colors = [
                'rgb(255, 99, 132)',
                'rgb(54, 162, 235)',
                'rgb(75, 192, 192)',
                'rgb(255, 206, 86)',
                'rgb(153, 102, 255)',
                'rgb(255, 159, 64)',
                'rgb(199, 199, 199)',
                'rgb(83, 102, 255)',
                'rgb(255, 99, 255)',
                'rgb(99, 255, 132)',
                'rgb(255, 132, 99)',
                'rgb(132, 99, 255)',
                'rgb(99, 255, 255)',
                'rgb(255, 255, 99)',
                'rgb(192, 75, 192)',
                'rgb(75, 192, 75)',
                'rgb(192, 192, 75)',
                'rgb(75, 75, 192)',
                'rgb(192, 75, 75)',
                'rgb(128, 128, 128)'
            ];
            
            const liftDatasets = [];
            const momentYDatasets = [];
            const momentZDatasets = [];
            const aoaDatasets = [];
            const velocityDatasets = [];
            const liftForceDatasets = [];
            
            // Individual blade datasets
            for (let i = 0; i < turbineParams.numBlades; i++) {
                liftDatasets.push({
                    label: `Blade ${i + 1} Thrust`,
                    data: [],
                    borderColor: colors[i % colors.length],
                    backgroundColor: colors[i % colors.length],
                    borderWidth: 1,
                    pointRadius: 0
                });
                
                momentYDatasets.push({
                    label: `Blade ${i + 1} My`,
                    data: [],
                    borderColor: colors[i % colors.length],
                    backgroundColor: colors[i % colors.length],
                    borderWidth: 1,
                    pointRadius: 0
                });
                
                momentZDatasets.push({
                    label: `Blade ${i + 1} Mz`,
                    data: [],
                    borderColor: colors[i % colors.length],
                    backgroundColor: colors[i % colors.length],
                    borderWidth: 1,
                    pointRadius: 0
                });
                
                aoaDatasets.push({
                    label: `Blade ${i + 1} AoA`,
                    data: [],
                    borderColor: colors[i % colors.length],
                    backgroundColor: colors[i % colors.length],
                    borderWidth: 1,
                    pointRadius: 0
                });
                
                velocityDatasets.push({
                    label: `Blade ${i + 1} Velocity`,
                    data: [],
                    borderColor: colors[i % colors.length],
                    backgroundColor: colors[i % colors.length],
                    borderWidth: 1,
                    pointRadius: 0
                });
                
                liftForceDatasets.push({
                    label: `Blade ${i + 1} Lift`,
                    data: [],
                    borderColor: colors[i % colors.length],
                    backgroundColor: colors[i % colors.length],
                    borderWidth: 1,
                    pointRadius: 0
                });
            }
            
            // Total datasets
            liftDatasets.push({
                label: 'Total Thrust',
                data: [],
                borderColor: 'rgb(0, 0, 0)',
                backgroundColor: 'rgb(0, 0, 0)',
                borderWidth: 2,
                pointRadius: 0
            });
            
            momentYDatasets.push({
                label: 'Total My',
                data: [],
                borderColor: 'rgb(0, 0, 0)',
                backgroundColor: 'rgb(0, 0, 0)',
                borderWidth: 2,
                pointRadius: 0
            });
            
            momentZDatasets.push({
                label: 'Total Mz',
                data: [],
                borderColor: 'rgb(0, 0, 0)',
                backgroundColor: 'rgb(0, 0, 0)',
                borderWidth: 2,
                pointRadius: 0
            });
            
            return { liftDatasets, momentYDatasets, momentZDatasets, aoaDatasets, velocityDatasets, liftForceDatasets };
        }
        
        // Initialize charts
        let chartDatasets = createChartDatasets();
        
        // Custom plugin to draw current position indicator
        const currentPositionPlugin = {
            id: 'currentPosition',
            afterDraw: (chart) => {
                if (chart.currentAzimuth !== null && chart.currentAzimuth !== undefined) {
                    const ctx = chart.ctx;
                    const xAxis = chart.scales.x;
                    const yAxis = chart.scales.y;
                    
                    // Find the x position for current azimuth
                    const labels = chart.data.labels;
                    let xPos = null;
                    
                    // Find closest label to current azimuth
                    let minDiff = Infinity;
                    let closestIndex = 0;
                    for (let i = 0; i < labels.length; i++) {
                        const labelValue = parseFloat(labels[i]);
                        const diff = Math.abs(labelValue - chart.currentAzimuth);
                        if (diff < minDiff) {
                            minDiff = diff;
                            closestIndex = i;
                        }
                    }
                    
                    if (closestIndex >= 0 && closestIndex < labels.length) {
                        xPos = xAxis.getPixelForValue(closestIndex);
                    }
                    
                    if (xPos !== null) {
                        ctx.save();
                        ctx.beginPath();
                        ctx.strokeStyle = 'rgba(255, 0, 0, 0.8)';
                        ctx.lineWidth = 2;
                        ctx.setLineDash([5, 5]);
                        ctx.moveTo(xPos, yAxis.top);
                        ctx.lineTo(xPos, yAxis.bottom);
                        ctx.stroke();
                        ctx.restore();
                    }
                }
            }
        };
        
        // Plugin to draw TDC (Top Dead Center) markers
        const tdcMarkerPlugin = {
            id: 'tdcMarker',
            afterDatasetsDraw(chart) {
                const { ctx, chartArea, scales } = chart;
                if (!chartArea || !plotData.tdcMarkers) return;
                
                ctx.save();
                ctx.strokeStyle = 'rgba(255, 0, 0, 0.6)';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                
                plotData.tdcMarkers.forEach(tdcTime => {
                    const x = scales.x.getPixelForValue(tdcTime);
                    if (x >= chartArea.left && x <= chartArea.right) {
                        ctx.beginPath();
                        ctx.moveTo(x, chartArea.top);
                        ctx.lineTo(x, chartArea.bottom);
                        ctx.stroke();
                        
                        // Draw "TDC" label
                        ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';
                        ctx.font = '10px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('TDC', x, chartArea.top - 5);
                    }
                });
                
                ctx.restore();
            }
        };
        
        // Zoom configuration for y-axis only (for all trace charts)
        const yAxisZoomConfig = {
            zoom: {
                wheel: {
                    enabled: true,
                },
                pinch: {
                    enabled: true
                },
                mode: 'y',
            },
            pan: {
                enabled: true,
                mode: 'y',
            }
        };
        
        const liftChartCtx = document.getElementById('lift-chart').getContext('2d');
        let liftChart = new Chart(liftChartCtx, {
            type: 'line',
            data: {
                labels: [],
                datasets: chartDatasets.liftDatasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                plugins: {
                    title: {
                        display: true,
                        text: 'Blade Thrust (non-rotating frame)'
                    },
                    legend: {
                        display: true,
                        position: 'top'
                    },
                    zoom: yAxisZoomConfig
                },
                scales: {
                    x: {
                        display: true,
                        type: 'linear',
                        title: {
                            display: true,
                            text: 'Time (rad)'
                        },
                        ticks: {
                            display: false  // Hide tick numbers
                        }
                    },
                    y: {
                        title: {
                            display: true,
                            text: 'Thrust'
                        }
                    }
                }
            },
            plugins: [currentPositionPlugin, tdcMarkerPlugin]
        });
        
        const momentYChartCtx = document.getElementById('moment-y-chart').getContext('2d');
        let momentYChart = new Chart(momentYChartCtx, {
            type: 'line',
            data: {
                labels: [],
                datasets: chartDatasets.momentYDatasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                plugins: {
                    title: {
                        display: true,
                        text: 'Yawing Moment (non-rotating frame)'
                    },
                    legend: {
                        display: true,
                        position: 'top'
                    },
                    zoom: yAxisZoomConfig
                },
                scales: {
                    x: {
                        display: true,
                        type: 'linear',
                        title: {
                            display: true,
                            text: 'Time (rad)'
                        },
                        ticks: {
                            display: false  // Hide tick numbers
                        }
                    },
                    y: {
                        title: {
                            display: true,
                            text: 'Moment Y'
                        }
                    }
                }
            },
            plugins: [currentPositionPlugin, tdcMarkerPlugin]
        });
        
        const momentZChartCtx = document.getElementById('moment-z-chart').getContext('2d');
        let momentZChart = new Chart(momentZChartCtx, {
            type: 'line',
            data: {
                labels: [],
                datasets: chartDatasets.momentZDatasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                plugins: {
                    title: {
                        display: true,
                        text: 'Nodding Moment (non-rotating frame)'
                    },
                    legend: {
                        display: true,
                        position: 'top'
                    },
                    zoom: yAxisZoomConfig
                },
                scales: {
                    x: {
                        display: true,
                        type: 'linear',
                        title: {
                            display: true,
                            text: 'Time (rad)'
                        },
                        ticks: {
                            display: false  // Hide tick numbers
                        }
                    },
                    y: {
                        title: {
                            display: true,
                            text: 'Moment Z'
                        }
                    }
                }
            },
            plugins: [currentPositionPlugin, tdcMarkerPlugin]
        });
        
        // AoA chart (no total, just individual blades)
        const aoaChartCtx = document.getElementById('aoa-chart').getContext('2d');
        let aoaChart = new Chart(aoaChartCtx, {
            type: 'line',
            data: {
                labels: [],
                datasets: chartDatasets.aoaDatasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                plugins: {
                    title: {
                        display: true,
                        text: 'Angle of Attack (degrees) (rotating frame)'
                    },
                    legend: {
                        display: true,
                        position: 'top'
                    },
                    zoom: yAxisZoomConfig
                },
                scales: {
                    x: {
                        display: true,
                        type: 'linear',
                        title: {
                            display: true,
                            text: 'Time (rad)'
                        },
                        ticks: {
                            display: false  // Hide tick numbers
                        }
                    },
                    y: {
                        title: {
                            display: true,
                            text: 'AoA (deg)'
                        }
                    }
                }
            },
            plugins: [currentPositionPlugin, tdcMarkerPlugin]
        });
        
        // Velocity chart (no total, just individual blades)
        const velocityChartCtx = document.getElementById('velocity-chart').getContext('2d');
        let velocityChart = new Chart(velocityChartCtx, {
            type: 'line',
            data: {
                labels: [],
                datasets: chartDatasets.velocityDatasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                plugins: {
                    title: {
                        display: true,
                        text: 'Total Velocity (m/s) (rotating frame)'
                    },
                    legend: {
                        display: true,
                        position: 'top'
                    },
                    zoom: yAxisZoomConfig
                },
                scales: {
                    x: {
                        display: true,
                        type: 'linear',
                        title: {
                            display: true,
                            text: 'Time (rad)'
                        },
                        ticks: {
                            display: false  // Hide tick numbers
                        }
                    },
                    y: {
                        title: {
                            display: true,
                            text: 'Velocity (m/s)'
                        }
                    }
                }
            },
            plugins: [currentPositionPlugin, tdcMarkerPlugin]
        });
        
        // Lift Force chart (no total, just individual blades)
        const liftForceChartCtx = document.getElementById('lift-force-chart').getContext('2d');
        let liftForceChart = new Chart(liftForceChartCtx, {
            type: 'line',
            data: {
                labels: [],
                datasets: chartDatasets.liftForceDatasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                plugins: {
                    title: {
                        display: true,
                        text: 'Lift Force (N) (rotating frame)'
                    },
                    legend: {
                        display: true,
                        position: 'top'
                    },
                    zoom: yAxisZoomConfig
                },
                scales: {
                    x: {
                        display: true,
                        type: 'linear',
                        title: {
                            display: true,
                            text: 'Time (rad)'
                        },
                        ticks: {
                            display: false  // Hide tick numbers
                        }
                    },
                    y: {
                        title: {
                            display: true,
                            text: 'Lift (N)'
                        }
                    }
                }
            },
            plugins: [currentPositionPlugin, tdcMarkerPlugin]
        });
        
        
        // Spanwise loading chart - empty scatter plot
        const spanwiseChartCanvas = document.getElementById('spanwise-chart');
        const spanwiseChartCtx = spanwiseChartCanvas.getContext('2d');
        const spanwiseChart = new Chart(spanwiseChartCtx, {
            type: 'scatter',
            data: {
                datasets: [{
                    label: 'Thrust',
                    data: [],
                    backgroundColor: 'transparent',
                    borderColor: '#4bc0c0',
                    pointRadius: 0,
                    showLine: true,
                    borderWidth: 2,
                    tension: 0.4
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                scales: {
                    x: {
                        type: 'linear',
                        title: { display: true, text: 'Blade Span (%)' },
                        min: 0,
                        max: 100
                    },
                    y: {
                        type: 'linear',
                        title: { display: true, text: 'Thrust per unit length (N/m)' },
                        min: -50,
                        max: 200
                    }
                },
                plugins: {
                    legend: { display: false }
                }
            }
        });
        
        // Section analysis chart - airfoil with velocity vectors
        const sectionChartCanvas = document.getElementById('section-chart');
        const sectionChartCtx = sectionChartCanvas.getContext('2d');
        
        // Store angle values for tooltips
        let sectionAngleValues = {
            phi: 0,
            alpha: 0,
            theta: 0,
            Vt: 0,
            Vn: 0,
            VR: 0,
            L: 0,
            D: 0,
            thrust: 0,
            tangent: 0
        };
        
        const sectionChart = new Chart(sectionChartCtx, {
            type: 'scatter',
            data: {
                datasets: [
                    {
                        label: 'Airfoil',
                        data: [],
                        backgroundColor: '#cccccc',
                        borderColor: '#666666',
                        pointRadius: 0,
                        showLine: true,
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4
                    },
                    {
                        label: 'V‚Çú',
                        data: [],
                        backgroundColor: 'transparent',
                        borderColor: '#ff6384',
                        pointRadius: 0,
                        showLine: true,
                        borderWidth: 3
                    },
                    {
                        label: 'V‚Çô',
                        data: [],
                        backgroundColor: 'transparent',
                        borderColor: '#36a2eb',
                        pointRadius: 0,
                        showLine: true,
                        borderWidth: 3
                    },
                    {
                        label: 'V·µ£',
                        data: [],
                        backgroundColor: 'transparent',
                        borderColor: '#4bc0c0',
                        pointRadius: 0,
                        showLine: true,
                        borderWidth: 3
                    },
                    {
                        label: 'L (Lift)',
                        data: [],
                        backgroundColor: 'transparent',
                        borderColor: '#9966ff',
                        pointRadius: 0,
                        showLine: true,
                        borderWidth: 3
                    },
                    {
                        label: 'D (Drag)',
                        data: [],
                        backgroundColor: 'transparent',
                        borderColor: '#ff9f40',
                        pointRadius: 0,
                        showLine: true,
                        borderWidth: 3
                    },
                    {
                        label: 'F·µ£ (Resultant)',
                        data: [],
                        backgroundColor: 'transparent',
                        borderColor: '#ff6384',
                        pointRadius: 0,
                        showLine: true,
                        borderWidth: 4
                    },
                    {
                        label: 'F‚Çú (Thrust)',
                        data: [],
                        backgroundColor: 'transparent',
                        borderColor: '#00cc00',
                        pointRadius: 0,
                        showLine: true,
                        borderWidth: 3
                    },
                    {
                        label: 'F‚Çú‚Çê‚Çô (Tangential)',
                        data: [],
                        backgroundColor: 'transparent',
                        borderColor: '#ff00ff',
                        pointRadius: 0,
                        showLine: true,
                        borderWidth: 3
                    },
                    {
                        label: 'Chord Line',
                        data: [],
                        backgroundColor: 'transparent',
                        borderColor: '#000000',
                        pointRadius: 0,
                        showLine: true,
                        borderWidth: 2,
                        borderDash: [5, 5]
                    },
                    {
                        label: 'œÜ',
                        data: [],
                        backgroundColor: 'transparent',
                        borderColor: '#4bc0c0',
                        pointRadius: 0,
                        showLine: true,
                        borderWidth: 2,
                        fill: false
                    },
                    {
                        label: 'Œ±',
                        data: [],
                        backgroundColor: 'transparent',
                        borderColor: '#9966ff',
                        pointRadius: 0,
                        showLine: true,
                        borderWidth: 2,
                        fill: false
                    },
                    {
                        label: 'Œ∏',
                        data: [],
                        backgroundColor: 'transparent',
                        borderColor: '#ff6384',
                        pointRadius: 0,
                        showLine: true,
                        borderWidth: 2,
                        fill: false
                    },
                    {
                        label: 'Chord Extension',
                        data: [],
                        backgroundColor: 'transparent',
                        borderColor: '#888888',
                        pointRadius: 0,
                        showLine: true,
                        borderWidth: 1,
                        borderDash: [3, 3],
                        fill: false,
                        hidden: false
                    },
                    {
                        label: 'V‚Çú Extension',
                        data: [],
                        backgroundColor: 'transparent',
                        borderColor: '#ff6384',
                        pointRadius: 0,
                        showLine: true,
                        borderWidth: 1,
                        borderDash: [3, 3],
                        fill: false,
                        hidden: false
                    },
                    {
                        label: 'V·µ£ Extension',
                        data: [],
                        backgroundColor: 'transparent',
                        borderColor: '#4bc0c0',
                        pointRadius: 0,
                        showLine: true,
                        borderWidth: 1,
                        borderDash: [3, 3],
                        fill: false,
                        hidden: false
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: true,
                aspectRatio: 1,
                animation: false,
                scales: {
                    x: {
                        type: 'linear',
                        title: { display: true, text: 'Chord Position' },
                        min: -3,
                        max: 3
                    },
                    y: {
                        type: 'linear',
                        title: { display: true, text: 'Height' },
                        min: -3,
                        max: 3
                    }
                },
                plugins: {
                    legend: { 
                        display: true, 
                        position: 'top',
                        labels: {
                            filter: function(item, chart) {
                                // Hide extension lines from legend (datasets 13, 14, 15)
                                return item.datasetIndex < 13;
                            }
                        },
                        onClick: function(e, legendItem, legend) {
                            const index = legendItem.datasetIndex;
                            const chart = legend.chart;
                            const meta = chart.getDatasetMeta(index);
                            
                            // Toggle visibility of clicked dataset
                            meta.hidden = meta.hidden === null ? !chart.data.datasets[index].hidden : null;
                            
                            // Sync extension line visibility with their parent datasets
                            // Œ∏ (12) -> V‚Çú Extension (14)
                            if (index === 12) {
                                const vtExtMeta = chart.getDatasetMeta(14);
                                vtExtMeta.hidden = meta.hidden;
                            }
                            // Œ± (11) -> Chord Extension (13)
                            if (index === 11) {
                                const chordExtMeta = chart.getDatasetMeta(13);
                                chordExtMeta.hidden = meta.hidden;
                            }
                            // œÜ (10) -> V·µ£ Extension (15)
                            if (index === 10) {
                                const vrExtMeta = chart.getDatasetMeta(15);
                                vrExtMeta.hidden = meta.hidden;
                            }
                            
                            chart.update();
                            
                            // Update 3D section plane to sync visibility
                            if (sectionPlane && document.getElementById('show-section-plane').checked) {
                                createSectionPlane();
                            }
                        }
                    },
                    tooltip: {
                        enabled: true,
                        mode: 'nearest',
                        intersect: false,
                        callbacks: {
                            title: function(context) {
                                const datasetIndex = context[0].datasetIndex;
                                const labels = [
                                    'Airfoil',
                                    'V‚Çú (Tangential Velocity)',
                                    'V‚Çô (Normal Velocity)',
                                    'V·µ£ (Resultant Velocity)',
                                    'L (Lift)',
                                    'D (Drag)',
                                    'F·µ£ (Resultant Force)',
                                    'F‚Çú (Thrust)',
                                    'F‚Çú‚Çê‚Çô (Tangential Force)',
                                    'Chord Line',
                                    'œÜ (Flow Angle)',
                                    'Œ± (Angle of Attack)',
                                    'Œ∏ (Pitch Angle)',
                                    'Chord Extension',
                                    'V‚Çú Extension',
                                    'V·µ£ Extension'
                                ];
                                return labels[datasetIndex];
                            },
                            label: function(context) {
                                const datasetIndex = context.datasetIndex;
                                const point = context.parsed;
                                
                                // For angle arcs, show the angle value instead of coordinates
                                if (datasetIndex === 10) { // œÜ
                                    return `œÜ = ${sectionAngleValues.phi.toFixed(2)}¬∞`;
                                } else if (datasetIndex === 11) { // Œ±
                                    return `Œ± = ${sectionAngleValues.alpha.toFixed(2)}¬∞`;
                                } else if (datasetIndex === 12) { // Œ∏
                                    return `Œ∏ = ${sectionAngleValues.theta.toFixed(2)}¬∞`;
                                } else if (datasetIndex === 1) { // V‚Çú
                                    return `V‚Çú = ${sectionAngleValues.Vt.toFixed(2)} m/s`;
                                } else if (datasetIndex === 2) { // V‚Çô
                                    return `V‚Çô = ${sectionAngleValues.Vn.toFixed(2)} m/s`;
                                } else if (datasetIndex === 3) { // V·µ£
                                    return `V·µ£ = ${sectionAngleValues.VR.toFixed(2)} m/s`;
                                } else if (datasetIndex === 4) { // Lift
                                    return `L = ${sectionAngleValues.L.toFixed(2)} N`;
                                } else if (datasetIndex === 5) { // Drag
                                    return `D = ${sectionAngleValues.D.toFixed(2)} N`;
                                } else if (datasetIndex === 7) { // Thrust
                                    return `F‚Çú = ${sectionAngleValues.thrust.toFixed(2)} N`;
                                } else if (datasetIndex === 8) { // Tangential Force
                                    return `F‚Çú‚Çê‚Çô = ${sectionAngleValues.tangent.toFixed(2)} N`;
                                } else if (datasetIndex === 0) { // Airfoil
                                    return `(${point.x.toFixed(2)}, ${point.y.toFixed(2)})`;
                                } else if (datasetIndex === 9) { // Chord Line
                                    return 'Chord Line';
                                } else if (datasetIndex === 6) { // Resultant Force
                                    return `F·µ£ = ${Math.sqrt(sectionAngleValues.L**2 + sectionAngleValues.D**2).toFixed(2)} N`;
                                } else if (datasetIndex >= 13) { // Extension lines
                                    return 'Reference line extension';
                                }
                                return `(${point.x.toFixed(2)}, ${point.y.toFixed(2)})`;
                            }
                        }
                    },
                    zoom: {
                        pan: {
                            enabled: true,
                            mode: 'xy'
                        },
                        zoom: {
                            wheel: {
                                enabled: true,
                                speed: 0.1
                            },
                            pinch: {
                                enabled: true
                            },
                            mode: 'xy'
                        }
                    }
                }
            }
        });
        
        // Now that charts are initialized, create the initial blades
        updateBladeCount();
        
        // Initial update of spanwise and section analysis (after a short delay to ensure blades are created)
        setTimeout(() => {
            calculateSpanwiseYAxisRange(); // Set y-axis based on actual load range
            updateSpanwiseChart();
            updateSectionDiagram();
        }, 100);
        
        // Event listeners (with URL state saving)
        document.getElementById('wind-speed').addEventListener('input', (e) => {
            turbineParams.windSpeed = parseFloat(e.target.value);
            document.getElementById('wind-speed-value').textContent = turbineParams.windSpeed.toFixed(1);
            createWindVectorArrow(); // Update wind arrow
            resetFourierCollection();
            resetLoadMinMax(); // Reset load min/max tracking
            setTimeout(() => calculateSpanwiseYAxisRange(), 50); // Recalculate y-axis for new wind speed
            updateSectionDiagram(); // Immediately update section analysis
            debouncedSaveState();
        });
        
        document.getElementById('shaft-speed').addEventListener('input', (e) => {
            turbineParams.shaftSpeed = parseFloat(e.target.value);
            document.getElementById('shaft-speed-value').textContent = turbineParams.shaftSpeed.toFixed(1);
            // Update angular velocity to match (when not in dynamic mode)
            if (!turbineParams.dynamicSpeed) {
                turbineParams.angularVelocity = turbineParams.shaftSpeed * 2 * Math.PI / 60;
            }
            resetFourierCollection();
            resetLoadMinMax(); // Reset load min/max tracking
            updateSectionDiagram(); // Immediately update section analysis
        });
        
        // Dynamic speed toggle
        document.getElementById('dynamic-speed').addEventListener('change', (e) => {
            turbineParams.dynamicSpeed = e.target.checked;
            const paramsDiv = document.getElementById('dynamic-speed-params');
            const shaftSpeedSlider = document.getElementById('shaft-speed');
            
            if (turbineParams.dynamicSpeed) {
                // Show dynamic parameters
                paramsDiv.style.display = 'block';
                // Initialize angular velocity from current shaft speed
                turbineParams.angularVelocity = turbineParams.shaftSpeed * 2 * Math.PI / 60;
                // Disable manual shaft speed control
                shaftSpeedSlider.disabled = true;
                shaftSpeedSlider.style.opacity = '0.5';
            } else {
                // Hide dynamic parameters
                paramsDiv.style.display = 'none';
                // Re-enable manual shaft speed control
                shaftSpeedSlider.disabled = false;
                shaftSpeedSlider.style.opacity = '1.0';
                // Sync shaft speed from current angular velocity
                turbineParams.shaftSpeed = turbineParams.angularVelocity * 60 / (2 * Math.PI);
                document.getElementById('shaft-speed-value').textContent = turbineParams.shaftSpeed.toFixed(1);
                shaftSpeedSlider.value = Math.min(20, turbineParams.shaftSpeed);
            }
            resetFourierCollection();
            resetLoadMinMax(); // Reset load min/max tracking
        });
        
        // Generator torque control
        document.getElementById('generator-torque').addEventListener('input', (e) => {
            turbineParams.generatorTorque = parseFloat(e.target.value);
            document.getElementById('gen-torque-value').textContent = turbineParams.generatorTorque.toFixed(0);
        });
        
        // Rotor inertia control
        document.getElementById('rotor-inertia').addEventListener('input', (e) => {
            turbineParams.rotorInertia = parseFloat(e.target.value);
            document.getElementById('rotor-inertia-value').textContent = turbineParams.rotorInertia.toFixed(0);
        });
        
        document.getElementById('pause-rotation').addEventListener('change', (e) => {
            turbineParams.paused = e.target.checked;
            if (turbineParams.paused) {
                // When pausing, set manual rotation to current rotation
                const currentRotationDeg = (rotorGroup.rotation.x * 180 / Math.PI) % 360;
                turbineParams.manualRotation = currentRotationDeg >= 0 ? currentRotationDeg : currentRotationDeg + 360;
                document.getElementById('manual-rotation').value = turbineParams.manualRotation;
                document.getElementById('manual-rotation-value').textContent = turbineParams.manualRotation.toFixed(1);
            }
        });
        
        document.getElementById('manual-rotation').addEventListener('input', (e) => {
            turbineParams.manualRotation = parseFloat(e.target.value);
            document.getElementById('manual-rotation-value').textContent = turbineParams.manualRotation.toFixed(1);
            if (turbineParams.paused) {
                // Directly set rotor rotation when paused
                rotorGroup.rotation.x = turbineParams.manualRotation * Math.PI / 180;
                updateSectionDiagram(); // Immediately update section analysis when manually rotating
            }
        });
        
        document.getElementById('blade-pitch').addEventListener('input', (e) => {
            turbineParams.bladePitch = parseFloat(e.target.value);
            document.getElementById('blade-pitch-value').textContent = turbineParams.bladePitch.toFixed(1);
            // Update visual blade pitch
            // Convert from new convention: 0¬∞ = in disc, 90¬∞ = feathered
            // To rotation: subtract from 90¬∞ to get actual pitch angle
            const actualPitchAngle = turbineParams.bladePitch - 90;
            blades.forEach(blade => {
                blade.pitchGroup.rotation.y = actualPitchAngle * Math.PI / 180;
            });
            resetLoadMinMax(); // Reset load min/max tracking
            updateSectionDiagram(); // Immediately update section analysis
        });
        
        // Twist Settings Modal Controls
        const twistModal = document.getElementById('twist-modal');
        const twistSettingsBtn = document.getElementById('twist-settings-btn');
        const twistCloseBtn = document.getElementById('twist-close-btn');
        const twistRootSlider = document.getElementById('twist-root');
        const twistTipSlider = document.getElementById('twist-tip');
        const twistRootDisplay = document.getElementById('twist-root-display');
        const twistTipDisplay = document.getElementById('twist-tip-display');
        
        // Total Loads Panel Controls
        const totalLoadsPanel = document.getElementById('total-loads-panel');
        const minimizeTotalLoadsBtn = document.getElementById('minimize-total-loads-btn');
        
        minimizeTotalLoadsBtn.addEventListener('click', () => {
            totalLoadsPanel.classList.toggle('minimized');
            
            if (totalLoadsPanel.classList.contains('minimized')) {
                // Store current dimensions before minimizing
                totalLoadsPanel.dataset.savedWidth = totalLoadsPanel.style.width || '600px';
                totalLoadsPanel.dataset.savedHeight = totalLoadsPanel.style.height || '500px';
                // Clear inline dimensions to allow CSS to take over
                totalLoadsPanel.style.width = '';
                totalLoadsPanel.style.height = '';
                minimizeTotalLoadsBtn.textContent = '+';
            } else {
                // Restore previous dimensions when expanding
                totalLoadsPanel.style.width = totalLoadsPanel.dataset.savedWidth || '600px';
                totalLoadsPanel.style.height = totalLoadsPanel.dataset.savedHeight || '500px';
                minimizeTotalLoadsBtn.textContent = '‚àí';
            }
        });
        
        // Show the panel by default (minimized)
        totalLoadsPanel.style.display = 'block';
        totalLoadsPanel.classList.add('minimized');
        minimizeTotalLoadsBtn.textContent = '+';
        
        // Make panel draggable
        (function() {
            const header = totalLoadsPanel.querySelector('.plot-header');
            let isDragging = false;
            let currentX;
            let currentY;
            let initialX;
            let initialY;
            let xOffset = 0;
            let yOffset = 0;
            
            // Get initial position
            const rect = totalLoadsPanel.getBoundingClientRect();
            xOffset = rect.left;
            yOffset = rect.top;
            
            header.addEventListener('mousedown', dragStart);
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', dragEnd);
            
            function dragStart(e) {
                // Don't drag if clicking the minimize button
                if (e.target === minimizeTotalLoadsBtn || e.target.closest('.minimize-btn')) {
                    return;
                }
                
                initialX = e.clientX - xOffset;
                initialY = e.clientY - yOffset;
                isDragging = true;
            }
            
            function drag(e) {
                if (isDragging) {
                    e.preventDefault();
                    currentX = e.clientX - initialX;
                    currentY = e.clientY - initialY;
                    xOffset = currentX;
                    yOffset = currentY;
                    
                    totalLoadsPanel.style.left = currentX + 'px';
                    totalLoadsPanel.style.top = currentY + 'px';
                    totalLoadsPanel.style.right = 'auto';
                }
            }
            
            function dragEnd(e) {
                initialX = currentX;
                initialY = currentY;
                isDragging = false;
            }
        })();
        
        // Tab switching for total loads panel
        document.querySelectorAll('#total-loads-panel .trace-tab-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const tab = btn.getAttribute('data-tab');
                
                // Update button states
                document.querySelectorAll('#total-loads-panel .trace-tab-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                
                // Update tab content visibility
                document.querySelectorAll('#total-loads-panel .trace-tab-content').forEach(content => {
                    content.classList.remove('active');
                });
                document.getElementById(`${tab}-tab`).classList.add('active');
            });
        });
        
        // Rebuild Total Load charts when blade count changes
        function rebuildTotalLoadCharts() {
            // Recreate datasets for all 6 charts
            const bladeColors = ['#ff6384', '#36a2eb', '#4bc0c0', '#ffcd56', '#9966ff', '#ff9f40', '#ff6384', '#c9cbcf'];
            
            // Helper to create blade datasets
            function makeBladeDatasets(colors) {
                const datasets = [];
                for (let i = 0; i < turbineParams.numBlades; i++) {
                    datasets.push({
                        label: `Blade ${i+1}`,
                        data: [],
                        borderColor: colors[i % colors.length],
                        backgroundColor: colors[i % colors.length],
                        borderWidth: 1.5,
                        pointRadius: 0
                    });
                }
                return datasets;
            }
            
            // 1. Thrust Rotating - just blade datasets
            thrustRotatingChart.data.datasets = makeBladeDatasets(bladeColors);
            thrustRotatingChart.data.labels = [];
            thrustRotatingChart.update('reset');
            
            // 2. Thrust Fixed - blade datasets + total
            thrustFixedChart.data.datasets = [
                ...makeBladeDatasets(bladeColors),
                {
                    label: 'Total',
                    data: [],
                    borderColor: '#000000',
                    backgroundColor: '#000000',
                    borderWidth: 3,
                    pointRadius: 0
                }
            ];
            thrustFixedChart.data.labels = [];
            thrustFixedChart.update('reset');
            
            // 3. Torque Rotating - just blade datasets
            torqueRotatingChart.data.datasets = makeBladeDatasets(bladeColors);
            torqueRotatingChart.data.labels = [];
            torqueRotatingChart.update('reset');
            
            // 4. Torque Fixed - blade datasets + total
            torqueFixedChart.data.datasets = [
                ...makeBladeDatasets(bladeColors),
                {
                    label: 'Total',
                    data: [],
                    borderColor: '#000000',
                    backgroundColor: '#000000',
                    borderWidth: 3,
                    pointRadius: 0
                }
            ];
            torqueFixedChart.data.labels = [];
            torqueFixedChart.update('reset');
            
            // 5. Nodding Moment - blade datasets + total
            noddingMomentChart.data.datasets = [
                ...makeBladeDatasets(bladeColors),
                {
                    label: 'Total',
                    data: [],
                    borderColor: '#000000',
                    backgroundColor: '#000000',
                    borderWidth: 3,
                    pointRadius: 0
                }
            ];
            noddingMomentChart.data.labels = [];
            noddingMomentChart.update('reset');
            
            // 6. Yawing Moment - blade datasets + total
            yawingMomentChart.data.datasets = [
                ...makeBladeDatasets(bladeColors),
                {
                    label: 'Total',
                    data: [],
                    borderColor: '#000000',
                    backgroundColor: '#000000',
                    borderWidth: 3,
                    pointRadius: 0
                }
            ];
            yawingMomentChart.data.labels = [];
            yawingMomentChart.update('reset');
        }
        
        // Initialize total loads charts (6 charts total)
        // Helper function to create blade datasets
        function createBladeDatasets(colors) {
            const datasets = [];
            for (let i = 0; i < turbineParams.numBlades; i++) {
                datasets.push({
                    label: `Blade ${i+1}`,
                    data: [],
                    borderColor: colors[i % colors.length],
                    backgroundColor: colors[i % colors.length],
                    borderWidth: 1.5,
                    pointRadius: 0
                });
            }
            return datasets;
        }
        
        const bladeColors = ['#ff6384', '#36a2eb', '#4bc0c0', '#ffcd56', '#9966ff', '#ff9f40', '#ff6384', '#c9cbcf'];
        
        // 1. Thrust - Rotating Frame (individual blade loads)
        const thrustRotatingCtx = document.getElementById('thrust-rotating-chart').getContext('2d');
        let thrustRotatingChart = new Chart(thrustRotatingCtx, {
            type: 'line',
            data: {
                labels: [],
                datasets: createBladeDatasets(bladeColors)
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                plugins: {
                    legend: { display: true, position: 'top' },
                    zoom: yAxisZoomConfig
                },
                scales: {
                    x: {
                        type: 'linear',
                        title: { display: true, text: 'Time (rad)' }
                    },
                    y: {
                        title: { display: true, text: 'Thrust (N)' },
                        suggestedMin: -100,
                        suggestedMax: 100
                    }
                }
            },
            plugins: [currentPositionPlugin, tdcMarkerPlugin]
        });
        
        // 2. Thrust - Fixed Frame (individual blades + total)
        const thrustFixedCtx = document.getElementById('thrust-fixed-chart').getContext('2d');
        let thrustFixedChart = new Chart(thrustFixedCtx, {
            type: 'line',
            data: {
                labels: [],
                datasets: [
                    ...createBladeDatasets(bladeColors),
                    {
                        label: 'Total',
                        data: [],
                        borderColor: '#000000',
                        backgroundColor: '#000000',
                        borderWidth: 3,
                        pointRadius: 0
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                plugins: {
                    legend: { display: true, position: 'top' },
                    zoom: yAxisZoomConfig
                },
                scales: {
                    x: {
                        type: 'linear',
                        title: { display: true, text: 'Time (rad)' }
                    },
                    y: {
                        title: { display: true, text: 'Thrust (N)' },
                        suggestedMin: -100,
                        suggestedMax: 100
                    }
                }
            },
            plugins: [currentPositionPlugin, tdcMarkerPlugin]
        });
        
        // 3. Torque - Rotating Frame (individual blade contributions)
        const torqueRotatingCtx = document.getElementById('torque-rotating-chart').getContext('2d');
        let torqueRotatingChart = new Chart(torqueRotatingCtx, {
            type: 'line',
            data: {
                labels: [],
                datasets: createBladeDatasets(bladeColors)
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                plugins: {
                    legend: { display: true, position: 'top' },
                    zoom: yAxisZoomConfig
                },
                scales: {
                    x: {
                        type: 'linear',
                        title: { display: true, text: 'Time (rad)' }
                    },
                    y: {
                        title: { display: true, text: 'Torque (N‚ãÖm)' },
                        suggestedMin: -1000,
                        suggestedMax: 1000
                    }
                }
            },
            plugins: [currentPositionPlugin, tdcMarkerPlugin]
        });
        
        // 4. Torque - Fixed Frame (individual blades + total)
        const torqueFixedCtx = document.getElementById('torque-fixed-chart').getContext('2d');
        let torqueFixedChart = new Chart(torqueFixedCtx, {
            type: 'line',
            data: {
                labels: [],
                datasets: [
                    ...createBladeDatasets(bladeColors),
                    {
                        label: 'Total',
                        data: [],
                        borderColor: '#000000',
                        backgroundColor: '#000000',
                        borderWidth: 3,
                        pointRadius: 0
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                plugins: {
                    legend: { display: true, position: 'top' },
                    zoom: yAxisZoomConfig
                },
                scales: {
                    x: {
                        type: 'linear',
                        title: { display: true, text: 'Time (rad)' }
                    },
                    y: {
                        title: { display: true, text: 'Torque (N‚ãÖm)' },
                        suggestedMin: -1000,
                        suggestedMax: 1000
                    }
                }
            },
            plugins: [currentPositionPlugin, tdcMarkerPlugin]
        });
        
        // 5. Nodding Moment - Fixed Frame Only (individual blades + total)
        const noddingMomentCtx = document.getElementById('nodding-moment-chart').getContext('2d');
        let noddingMomentChart = new Chart(noddingMomentCtx, {
            type: 'line',
            data: {
                labels: [],
                datasets: [
                    ...createBladeDatasets(bladeColors),
                    {
                        label: 'Total',
                        data: [],
                        borderColor: '#000000',
                        backgroundColor: '#000000',
                        borderWidth: 3,
                        pointRadius: 0
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                plugins: {
                    legend: { display: true, position: 'top' },
                    zoom: yAxisZoomConfig
                },
                scales: {
                    x: {
                        type: 'linear',
                        title: { display: true, text: 'Time (rad)' }
                    },
                    y: {
                        title: { display: true, text: 'Nodding Moment (N‚ãÖm)' },
                        suggestedMin: -1000,
                        suggestedMax: 1000
                    }
                }
            },
            plugins: [currentPositionPlugin, tdcMarkerPlugin]
        });
        
        // 6. Yawing Moment - Fixed Frame Only (individual blades + total)
        const yawingMomentCtx = document.getElementById('yawing-moment-chart').getContext('2d');
        let yawingMomentChart = new Chart(yawingMomentCtx, {
            type: 'line',
            data: {
                labels: [],
                datasets: [
                    ...createBladeDatasets(bladeColors),
                    {
                        label: 'Total',
                        data: [],
                        borderColor: '#000000',
                        backgroundColor: '#000000',
                        borderWidth: 3,
                        pointRadius: 0
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                plugins: {
                    legend: { display: true, position: 'top' },
                    zoom: yAxisZoomConfig
                },
                scales: {
                    x: {
                        type: 'linear',
                        title: { display: true, text: 'Time (rad)' }
                    },
                    y: {
                        title: { display: true, text: 'Yawing Moment (N‚ãÖm)' },
                        suggestedMin: -1000,
                        suggestedMax: 1000
                    }
                }
            },
            plugins: [currentPositionPlugin, tdcMarkerPlugin]
        });
        
        // Function to update total loads charts
        function updateTotalLoadsCharts() {
            // Calculate dynamic x-axis bounds (match Load Traces behavior)
            let xMin = 0;
            let xMax = 4 * Math.PI;
            
            if (plotData.time.length > 0) {
                const firstTime = parseFloat(plotData.time[0]);
                const lastTime = parseFloat(plotData.time[plotData.time.length - 1]);
                
                // If we haven't filled the buffer yet, show from 0 to current max (clipped to 4œÄ)
                const maxDataPoints = Math.ceil((360 * 2) / turbineParams.angularResolution);
                if (plotData.time.length < maxDataPoints) {
                    xMin = 0;
                    xMax = Math.min(lastTime, 4 * Math.PI); // Clip to data or 4œÄ, whichever is smaller
                } else {
                    // Once full, scroll with the data
                    xMin = firstTime;
                    xMax = lastTime;
                }
            }
            
            const normalizedCurrentAzimuth = ((rotorGroup.rotation.x % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);
            
            // Update all charts with common settings
            [thrustRotatingChart, thrustFixedChart, torqueRotatingChart, torqueFixedChart,
             noddingMomentChart, yawingMomentChart].forEach(chart => {
                chart.data.labels = plotData.time;
                chart.options.scales.x.min = xMin;
                chart.options.scales.x.max = xMax;
                chart.currentAzimuth = turbineParams.paused ? normalizedCurrentAzimuth : null;
            });
            
            // 1. Thrust rotating - individual blade loads
            for (let i = 0; i < turbineParams.numBlades; i++) {
                thrustRotatingChart.data.datasets[i].data = plotData.bladeLift[i] || [];
            }
            thrustRotatingChart.update('none');
            
            // 2. Thrust fixed - individual blades + total
            for (let i = 0; i < turbineParams.numBlades; i++) {
                thrustFixedChart.data.datasets[i].data = plotData.bladeLift[i] || [];
            }
            thrustFixedChart.data.datasets[turbineParams.numBlades].data = plotData.totalThrust;
            thrustFixedChart.update('none');
            
            // 3. Torque rotating - individual blade contributions
            for (let i = 0; i < turbineParams.numBlades; i++) {
                torqueRotatingChart.data.datasets[i].data = plotData.bladeLift[i] || [];
            }
            torqueRotatingChart.update('none');
            
            // 4. Torque fixed - individual blades + total
            for (let i = 0; i < turbineParams.numBlades; i++) {
                torqueFixedChart.data.datasets[i].data = plotData.bladeLift[i] || [];
            }
            torqueFixedChart.data.datasets[turbineParams.numBlades].data = plotData.totalTorque;
            torqueFixedChart.update('none');
            
            // 5. Nodding moment - individual blades + total
            for (let i = 0; i < turbineParams.numBlades; i++) {
                noddingMomentChart.data.datasets[i].data = plotData.bladeMomentY[i] || [];
            }
            noddingMomentChart.data.datasets[turbineParams.numBlades].data = plotData.totalMomentY;
            noddingMomentChart.update('none');
            
            // 6. Yawing moment - individual blades + total
            for (let i = 0; i < turbineParams.numBlades; i++) {
                yawingMomentChart.data.datasets[i].data = plotData.bladeMomentZ[i] || [];
            }
            yawingMomentChart.data.datasets[turbineParams.numBlades].data = plotData.totalMomentZ;
            yawingMomentChart.update('none');
        }
        
        // Function to update rotor loads display (for yaw/nod moment text)
        function updateRotorLoadsDisplay(thrust, torque, hubMoment, yawMoment, nodMoment) {
            // Format numbers with appropriate precision
            const formatValue = (val) => {
                if (Math.abs(val) < 1000) return val.toFixed(1);
                if (Math.abs(val) < 1000000) return (val / 1000).toFixed(1) + 'k';
                return (val / 1000000).toFixed(2) + 'M';
            };
            
            // Update charts
            updateTotalLoadsCharts();
        }
        
        // Function to reset load tracking (now just updates Fourier)
        function resetLoadMinMax() {
            // This function is called when controls change
            // Charts will automatically show new data
        }
        
        // Open modal
        twistSettingsBtn.addEventListener('click', () => {
            twistModal.style.display = 'flex';
        });
        
        // Close modal
        twistCloseBtn.addEventListener('click', () => {
            twistModal.style.display = 'none';
        });
        
        // Close on background click
        twistModal.addEventListener('click', (e) => {
            if (e.target === twistModal) {
                twistModal.style.display = 'none';
            }
        });
        
        // Root twist slider
        twistRootSlider.addEventListener('input', (e) => {
            turbineParams.twistRoot = parseFloat(e.target.value);
            twistRootDisplay.textContent = turbineParams.twistRoot.toFixed(1);
            resetFourierCollection();
            resetLoadMinMax(); // Reset load min/max tracking
            updateSectionDiagram(); // Immediately update section analysis
        });
        
        // Tip twist slider
        twistTipSlider.addEventListener('input', (e) => {
            turbineParams.twistTip = parseFloat(e.target.value);
            twistTipDisplay.textContent = turbineParams.twistTip.toFixed(1);
            resetFourierCollection();
            resetLoadMinMax(); // Reset load min/max tracking
            updateSectionDiagram(); // Immediately update section analysis
        });
        
        // Preset buttons
        document.querySelectorAll('.twist-preset').forEach(btn => {
            btn.addEventListener('click', () => {
                const root = parseFloat(btn.getAttribute('data-root'));
                const tip = parseFloat(btn.getAttribute('data-tip'));
                
                turbineParams.twistRoot = root;
                turbineParams.twistTip = tip;
                
                twistRootSlider.value = root;
                twistTipSlider.value = tip;
                twistRootDisplay.textContent = root.toFixed(1);
                twistTipDisplay.textContent = tip.toFixed(1);
                
                resetFourierCollection();
                resetLoadMinMax(); // Reset load min/max tracking
                updateSectionDiagram(); // Immediately update section analysis
            });
        });
        
        document.getElementById('num-blades').addEventListener('input', (e) => {
            turbineParams.numBlades = parseInt(e.target.value);
            document.getElementById('num-blades-value').textContent = turbineParams.numBlades;
            updateBladeCount();
        });
        
        document.getElementById('yaw').addEventListener('input', (e) => {
            turbineParams.yawAngle = parseFloat(e.target.value);
            document.getElementById('yaw-value').textContent = turbineParams.yawAngle.toFixed(1);
            // Don't rotate nacelle - yaw now represents wind direction, turbine stays fixed
            createWindVectorArrow(); // Update wind arrow
            resetFourierCollection();
            resetLoadMinMax(); // Reset load min/max tracking
            setTimeout(() => calculateSpanwiseYAxisRange(), 50); // Recalculate y-axis for new yaw
            updateSectionDiagram(); // Immediately update section analysis
        });
        
        document.getElementById('inflow').addEventListener('input', (e) => {
            turbineParams.inflowAngle = parseFloat(e.target.value);
            document.getElementById('inflow-value').textContent = turbineParams.inflowAngle.toFixed(1);
            createWindVectorArrow(); // Update wind arrow
            resetFourierCollection();
            resetLoadMinMax(); // Reset load min/max tracking
            setTimeout(() => calculateSpanwiseYAxisRange(), 50); // Recalculate y-axis for new inflow
            updateSectionDiagram(); // Immediately update section analysis
        });
        
        document.getElementById('show-axes').addEventListener('change', (e) => {
            const show = e.target.checked;
            sceneAxes.visible = show;
            rotorAxes.visible = show;
            nacelleAxes.visible = show;
        });
        
        
        document.getElementById('wind-farm-mode').addEventListener('change', (e) => {
            turbineParams.windFarmMode = e.target.checked;
            createWindFarm();
        });
        
        document.getElementById('show-heatmap').addEventListener('change', (e) => {
            turbineParams.showHeatmap = e.target.checked;
        });
        
        document.getElementById('debug-camber').addEventListener('change', (e) => {
            turbineParams.debugCamber = e.target.checked;
            // Rebuild blades with new camber
            updateBladeCount();
            updateSectionDiagram(); // Immediately update section analysis
        });
        
        document.getElementById('simple-aero').addEventListener('change', (e) => {
            turbineParams.simpleAero = e.target.checked;
            // No need to rebuild blades, aerodynamics will update automatically
            updateSectionDiagram(); // Immediately update section analysis
        });
        
        document.getElementById('show-wind-vector').addEventListener('change', (e) => {
            turbineParams.showWindVector = e.target.checked;
            createWindVectorArrow(); // Update visibility
        });
        
        document.getElementById('remove-mean').addEventListener('change', (e) => {
            turbineParams.removeMean = e.target.checked;
            resetFourierCollection();
        });
        
        document.getElementById('debug-sinusoid').addEventListener('change', (e) => {
            turbineParams.debugSinusoid = e.target.checked;
            resetFourierCollection();
        });
        
        document.getElementById('show-vectors').addEventListener('change', (e) => {
            turbineParams.showVectors = e.target.checked;
        });
        
        document.getElementById('vector-mode').addEventListener('change', (e) => {
            turbineParams.vectorMode = e.target.value;
        });
        
        document.getElementById('vector-scale').addEventListener('input', (e) => {
            turbineParams.vectorScale = parseFloat(e.target.value);
            document.getElementById('vector-scale-value').textContent = turbineParams.vectorScale.toFixed(3);
        });
        
        document.getElementById('angular-resolution').addEventListener('input', (e) => {
            turbineParams.angularResolution = parseFloat(e.target.value);
            const value = turbineParams.angularResolution;
            // Display with appropriate precision
            if (value < 1) {
                document.getElementById('angular-res-value').textContent = value.toFixed(3);
            } else {
                document.getElementById('angular-res-value').textContent = value.toFixed(1);
            }
            // Reset plot data when resolution changes
            initPlotData();
            rebuildCharts();
            for (let i = 0; i < turbineParams.numBlades; i++) {
                plotData.bladeLift[i] = [];
                plotData.bladeMomentY[i] = [];
                plotData.bladeMomentZ[i] = [];
                plotData.bladeAoA[i] = [];
                plotData.bladeVelocity[i] = [];
            }
            timeCounter = 0;
            resetFourierCollection();
        });
        
        // Radial station control (Load Traces)
        document.getElementById('radial-station').addEventListener('input', (e) => {
            const percent = parseInt(e.target.value);
            turbineParams.radialStation = percent / 100;
            document.getElementById('station-value').textContent = percent;
            // Sync to section analysis slider
            document.getElementById('section-radial-station').value = percent;
            document.getElementById('section-station-value').textContent = percent;
            // Update section plane if visible
            if (document.getElementById('show-section-plane').checked) {
                createSectionPlane();
            }
            // Reset plot data when station changes
            initPlotData();
            rebuildCharts();
            // Reset arrays
            for (let i = 0; i < turbineParams.numBlades; i++) {
                plotData.bladeLift[i] = [];
                plotData.bladeMomentY[i] = [];
                plotData.bladeMomentZ[i] = [];
                plotData.bladeAoA[i] = [];
                plotData.bladeVelocity[i] = [];
            }
            timeCounter = 0;
        });
        
        // Radial station control (Section Analysis) - synced with Load Traces
        document.getElementById('section-radial-station').addEventListener('input', (e) => {
            const percent = parseInt(e.target.value);
            turbineParams.radialStation = percent / 100;
            document.getElementById('section-station-value').textContent = percent;
            // Sync to load traces slider
            document.getElementById('radial-station').value = percent;
            document.getElementById('station-value').textContent = percent;
            // Update section diagram immediately
            updateSectionDiagram();
            // Update section plane if it's visible
            if (document.getElementById('show-section-plane').checked) {
                createSectionPlane();
            }
            // Reset plot data when station changes
            initPlotData();
            rebuildCharts();
            // Reset arrays
            for (let i = 0; i < turbineParams.numBlades; i++) {
                plotData.bladeLift[i] = [];
                plotData.bladeMomentY[i] = [];
                plotData.bladeMomentZ[i] = [];
                plotData.bladeAoA[i] = [];
                plotData.bladeVelocity[i] = [];
            }
            timeCounter = 0;
        });
        
        // Force scale control (Section Analysis)
        document.getElementById('force-scale').addEventListener('input', (e) => {
            turbineParams.forceScale = parseFloat(e.target.value);
            document.getElementById('force-scale-value').textContent = turbineParams.forceScale.toFixed(1);
            // Update section diagram immediately
            updateSectionDiagram();
        });
        
        // Spanwise force type selector
        document.getElementById('spanwise-force-type').addEventListener('change', () => {
            updateSpanwiseChart();
        });
        
        // Reverse axis checkboxes for section chart
        document.getElementById('reverse-x-axis').addEventListener('change', (e) => {
            sectionChart.options.scales.x.reverse = e.target.checked;
            sectionChart.update();
        });
        
        document.getElementById('reverse-y-axis').addEventListener('change', (e) => {
            sectionChart.options.scales.y.reverse = e.target.checked;
            sectionChart.update();
        });
        
        // Show section plane checkbox
        document.getElementById('show-section-plane').addEventListener('change', (e) => {
            toggleSectionPlane(e.target.checked);
        });
        
        // 3D Model opacity control
        document.getElementById('model-opacity').addEventListener('input', (e) => {
            const opacity = parseFloat(e.target.value);
            document.getElementById('model-opacity-value').textContent = opacity.toFixed(2);
            update3DModelOpacity(opacity);
        });
        
        // Reset zoom button for section chart
        document.getElementById('reset-zoom-btn').addEventListener('click', () => {
            if (sectionChart) {
                sectionChart.resetZoom();
            }
        });
        
        // Add custom pan functionality to section chart
        let isPanning = false;
        let panStartX = 0;
        let panStartY = 0;
        
        sectionChartCanvas.addEventListener('mousedown', (e) => {
            isPanning = true;
            panStartX = e.clientX;
            panStartY = e.clientY;
            sectionChartCanvas.style.cursor = 'grabbing';
        });
        
        sectionChartCanvas.addEventListener('mousemove', (e) => {
            if (!isPanning) return;
            
            const deltaX = e.clientX - panStartX;
            const deltaY = e.clientY - panStartY;
            
            // Get current scale ranges
            const xScale = sectionChart.scales.x;
            const yScale = sectionChart.scales.y;
            
            // Calculate pan amount based on pixel movement
            const xRange = xScale.max - xScale.min;
            const yRange = yScale.max - yScale.min;
            
            // Check if axes are reversed and adjust pan direction accordingly
            const xReversed = sectionChart.options.scales.x.reverse || false;
            const yReversed = sectionChart.options.scales.y.reverse || false;
            
            const xPan = -(deltaX / sectionChartCanvas.width) * xRange * (xReversed ? -1 : 1);
            const yPan = (deltaY / sectionChartCanvas.height) * yRange * (yReversed ? -1 : 1);
            
            // Update scales
            sectionChart.options.scales.x.min = xScale.min + xPan;
            sectionChart.options.scales.x.max = xScale.max + xPan;
            sectionChart.options.scales.y.min = yScale.min + yPan;
            sectionChart.options.scales.y.max = yScale.max + yPan;
            
            sectionChart.update('none');
            
            panStartX = e.clientX;
            panStartY = e.clientY;
        });
        
        sectionChartCanvas.addEventListener('mouseup', () => {
            isPanning = false;
            sectionChartCanvas.style.cursor = 'default';
        });
        
        sectionChartCanvas.addEventListener('mouseleave', () => {
            isPanning = false;
            sectionChartCanvas.style.cursor = 'default';
        });
                
        // Debug data generation
        document.getElementById('generate-debug').addEventListener('click', () => {
            generateDebugData();
        });
        
        // Generate debug table for 2-blade turbine
        function generateDebugData() {
            const output = document.getElementById('debug-output');
            
            output.innerHTML = '<p>Generating debug data for 2-blade turbine...</p>';
            output.innerHTML += `<p><strong>Configuration:</strong> Wind Speed=${turbineParams.windSpeed.toFixed(1)} m/s, Shaft Speed=${turbineParams.shaftSpeed.toFixed(1)} RPM, Yaw=${turbineParams.yawAngle}¬∞, Inflow=${turbineParams.inflowAngle}¬∞</p>`;
            output.innerHTML += `<p><strong>Radial Station:</strong> ${(turbineParams.radialStation * 100).toFixed(0)}% span</p>`;
            
            // Axis system info
            output.innerHTML += '<hr>';
            output.innerHTML += '<h3>Coordinate System</h3>';
            output.innerHTML += '<p><strong>THREE.js Convention:</strong> X-axis points downstream (into wind), Y-axis points up, Z-axis to the side</p>';
            output.innerHTML += '<p><strong>Rotor:</strong> Rotates about X-axis. rotation.x = angle</p>';
            output.innerHTML += '<p><strong>Blade positioning:</strong></p>';
            output.innerHTML += '<ul>';
            output.innerHTML += '<li>rotation.x = 0 ‚Üí Blade at Y+ (top of disc, 12 o\'clock)</li>';
            output.innerHTML += '<li>rotation.x = œÄ/2 ‚Üí Blade at Z+ (3 o\'clock looking downstream)</li>';
            output.innerHTML += '<li>rotation.x = œÄ ‚Üí Blade at Y- (bottom of disc, 6 o\'clock)</li>';
            output.innerHTML += '<li>rotation.x = 3œÄ/2 ‚Üí Blade at Z- (9 o\'clock looking downstream)</li>';
            output.innerHTML += '</ul>';
            output.innerHTML += '<p><strong>Expected with Yaw:</strong> Peak thrust when blade is on advancing side (Z+), minimum on retreating side (Z-)</p>';
            output.innerHTML += '<hr>';
            
            // Calculate thrust for 2 revolutions at 10-degree intervals
            const debugData = [];
            const omega = turbineParams.shaftSpeed * 2 * Math.PI / 60;
            const windSpeed = turbineParams.windSpeed;
            const yawRadians = turbineParams.yawAngle * Math.PI / 180;
            const inflowRadians = turbineParams.inflowAngle * Math.PI / 180;
            const windSpeedAxial = windSpeed * Math.cos(yawRadians);
            const windSpeedTangential = windSpeed * Math.sin(yawRadians);
            const targetRadius = turbineParams.radialStation * turbineParams.bladeRadius;
            
            // Get the chord at target radius (approximate from blade segments)
            let chord = 1.0; // default
            if (blades.length > 0 && blades[0].segments.length > 0) {
                let closestSegment = blades[0].segments[0];
                let minDist = Infinity;
                blades[0].segments.forEach(segment => {
                    const dist = Math.abs(segment.userData.radius - targetRadius);
                    if (dist < minDist) {
                        minDist = dist;
                        closestSegment = segment;
                    }
                });
                chord = closestSegment.userData.chord;
            }
            
            // Calculate for 2 revolutions at 10-degree resolution
            for (let angleDeg = 0; angleDeg < 720; angleDeg += 10) {
                const angle = angleDeg * Math.PI / 180;
                
                // Blade 1 azimuth (starts at 0)
                const azimuth1 = angle;
                const thrust1 = calculateThrustAtAzimuth(azimuth1, targetRadius, chord, omega, windSpeedAxial, windSpeedTangential, inflowRadians);
                
                // Blade 2 azimuth (180 degrees offset)
                const azimuth2 = angle + Math.PI;
                const thrust2 = calculateThrustAtAzimuth(azimuth2, targetRadius, chord, omega, windSpeedAxial, windSpeedTangential, inflowRadians);
                
                // Position descriptions
                const pos1 = getPositionDescription((azimuth1 * 180 / Math.PI) % 360);
                const pos2 = getPositionDescription((azimuth2 * 180 / Math.PI) % 360);
                
                debugData.push({
                    angle: angleDeg,
                    azimuth1Deg: (azimuth1 * 180 / Math.PI) % 360,
                    azimuth2Deg: (azimuth2 * 180 / Math.PI) % 360,
                    thrust1: thrust1,
                    thrust2: thrust2,
                    diff: Math.abs(thrust1 - thrust2),
                    pos1: pos1,
                    pos2: pos2
                });
            }
            
            // Find crossings (where thrust1 and thrust2 are approximately equal)
            const crossings = [];
            for (let i = 1; i < debugData.length; i++) {
                const prev = debugData[i-1];
                const curr = debugData[i];
                
                // Check if lines cross (sign change in difference)
                if ((prev.thrust1 - prev.thrust2) * (curr.thrust1 - curr.thrust2) < 0) {
                    // Linear interpolation to find exact crossing
                    const t = Math.abs(prev.thrust1 - prev.thrust2) / (Math.abs(prev.thrust1 - prev.thrust2) + Math.abs(curr.thrust1 - curr.thrust2));
                    const crossAngle = prev.angle + t * (curr.angle - prev.angle);
                    const crossThrust = prev.thrust1 + t * (curr.thrust1 - prev.thrust1);
                    crossings.push({ angle: crossAngle, thrust: crossThrust });
                }
            }
            
            // Build HTML table
            let html = '<h3>Debug Data Table</h3>';
            html += '<table style="border-collapse: collapse; width: 100%; font-size: 0.85em;">';
            html += '<thead><tr style="background: #667eea; color: white;">';
            html += '<th style="border: 1px solid #ddd; padding: 8px;">Rotor Angle</th>';
            html += '<th style="border: 1px solid #ddd; padding: 8px;">Blade 1 Az</th>';
            html += '<th style="border: 1px solid #ddd; padding: 8px;">Position</th>';
            html += '<th style="border: 1px solid #ddd; padding: 8px;">Blade 1 Thrust</th>';
            html += '<th style="border: 1px solid #ddd; padding: 8px;">Blade 2 Az</th>';
            html += '<th style="border: 1px solid #ddd; padding: 8px;">Position</th>';
            html += '<th style="border: 1px solid #ddd; padding: 8px;">Blade 2 Thrust</th>';
            html += '<th style="border: 1px solid #ddd; padding: 8px;">|Diff|</th>';
            html += '</tr></thead><tbody>';
            
            debugData.forEach((row, idx) => {
                const bgColor = idx % 2 === 0 ? '#f9f9f9' : '#ffffff';
                html += `<tr style="background: ${bgColor};">`;
                html += `<td style="border: 1px solid #ddd; padding: 6px; text-align: center;">${row.angle.toFixed(0)}¬∞</td>`;
                html += `<td style="border: 1px solid #ddd; padding: 6px; text-align: center;">${row.azimuth1Deg.toFixed(1)}¬∞</td>`;
                html += `<td style="border: 1px solid #ddd; padding: 6px; text-align: center; font-size: 0.8em;">${row.pos1}</td>`;
                html += `<td style="border: 1px solid #ddd; padding: 6px; text-align: right; font-weight: bold;">${row.thrust1.toFixed(3)}</td>`;
                html += `<td style="border: 1px solid #ddd; padding: 6px; text-align: center;">${row.azimuth2Deg.toFixed(1)}¬∞</td>`;
                html += `<td style="border: 1px solid #ddd; padding: 6px; text-align: center; font-size: 0.8em;">${row.pos2}</td>`;
                html += `<td style="border: 1px solid #ddd; padding: 6px; text-align: right; font-weight: bold;">${row.thrust2.toFixed(3)}</td>`;
                html += `<td style="border: 1px solid #ddd; padding: 6px; text-align: right; color: ${row.diff < 0.1 ? 'green' : 'black'};">${row.diff.toFixed(3)}</td>`;
                html += '</tr>';
            });
            
            html += '</tbody></table>';
            
            // Add crossings info
            html += '<h3 style="margin-top: 20px;">Crossings (where Thrust1 ‚âà Thrust2)</h3>';
            if (turbineParams.yawAngle === 0 && turbineParams.inflowAngle === 0) {
                html += '<p><strong>Expected with no yaw/inflow:</strong> Thrusts should be equal everywhere (constant), so any "crossings" are numerical artifacts.</p>';
            } else {
                html += '<p><strong>Expected with yaw or inflow:</strong> Crossings at 90¬∞ and 270¬∞ (advancing/retreating sides)</p>';
            }
            if (crossings.length > 0) {
                html += '<ul>';
                crossings.forEach((cross, idx) => {
                    const expected = 90 + idx * 180;
                    const error = cross.angle - expected;
                    html += `<li>Crossing ${idx+1}: <strong>${cross.angle.toFixed(2)}¬∞</strong> (thrust=${cross.thrust.toFixed(3)}) - Expected: ${expected}¬∞ - <span style="color: ${Math.abs(error) < 5 ? 'green' : 'red'};">Error: ${error.toFixed(2)}¬∞</span></li>`;
                });
                html += '</ul>';
            } else {
                html += '<p style="color: red;">No crossings found!</p>';
            }
            
            // Fourier Analysis
            html += '<h3 style="margin-top: 30px;">Fourier Analysis (Harmonics)</h3>';
            html += '<p>Decomposition into 0P (mean), 1P, 2P, 3P, and 4P harmonics</p>';
            
            // Extract one full revolution for each blade
            const blade1Thrust = [];
            const blade2Thrust = [];
            const blade1MomentY = [];
            const blade2MomentY = [];
            const blade1MomentZ = [];
            const blade2MomentZ = [];
            
            for (let i = 0; i < 36; i++) { // 0-360 degrees in 10-degree steps
                const row = debugData[i];
                blade1Thrust.push(row.thrust1);
                blade2Thrust.push(row.thrust2);
                
                // Calculate moments (same as in updatePlotData)
                const azimuth1 = row.azimuth1Deg * Math.PI / 180;
                const azimuth2 = row.azimuth2Deg * Math.PI / 180;
                const r = targetRadius;
                
                blade1MomentY.push(row.thrust1 * r * Math.sin(azimuth1));
                blade1MomentZ.push(-row.thrust1 * r * Math.cos(azimuth1));
                blade2MomentY.push(row.thrust2 * r * Math.sin(azimuth2));
                blade2MomentZ.push(-row.thrust2 * r * Math.cos(azimuth2));
            }
            
            // Perform Fourier analysis
            const blade1ThrustFourier = analyzeFourier(blade1Thrust);
            const blade2ThrustFourier = analyzeFourier(blade2Thrust);
            const blade1MomentYFourier = analyzeFourier(blade1MomentY);
            const blade2MomentYFourier = analyzeFourier(blade2MomentY);
            const blade1MomentZFourier = analyzeFourier(blade1MomentZ);
            const blade2MomentZFourier = analyzeFourier(blade2MomentZ);
            
            // Display results
            html += '<h4>Blade 1 Thrust</h4>';
            html += '<table style="border-collapse: collapse; font-size: 0.9em; margin-bottom: 15px;">';
            html += '<thead><tr style="background: #667eea; color: white;">';
            html += '<th style="border: 1px solid #ddd; padding: 6px;">Harmonic</th>';
            html += '<th style="border: 1px solid #ddd; padding: 6px;">Amplitude</th>';
            html += '<th style="border: 1px solid #ddd; padding: 6px;">Phase (deg)</th>';
            html += '</tr></thead><tbody>';
            blade1ThrustFourier.forEach((h, idx) => {
                const bgColor = idx % 2 === 0 ? '#f9f9f9' : '#ffffff';
                html += `<tr style="background: ${bgColor};">`;
                html += `<td style="border: 1px solid #ddd; padding: 6px; text-align: center;">${h.harmonic}P</td>`;
                html += `<td style="border: 1px solid #ddd; padding: 6px; text-align: right;">${h.amplitude.toFixed(3)}</td>`;
                html += `<td style="border: 1px solid #ddd; padding: 6px; text-align: right;">${h.phase.toFixed(1)}¬∞</td>`;
                html += '</tr>';
            });
            html += '</tbody></table>';
            
            html += '<h4>Blade 2 Thrust</h4>';
            html += '<table style="border-collapse: collapse; font-size: 0.9em; margin-bottom: 15px;">';
            html += '<thead><tr style="background: #667eea; color: white;">';
            html += '<th style="border: 1px solid #ddd; padding: 6px;">Harmonic</th>';
            html += '<th style="border: 1px solid #ddd; padding: 6px;">Amplitude</th>';
            html += '<th style="border: 1px solid #ddd; padding: 6px;">Phase (deg)</th>';
            html += '</tr></thead><tbody>';
            blade2ThrustFourier.forEach((h, idx) => {
                const bgColor = idx % 2 === 0 ? '#f9f9f9' : '#ffffff';
                html += `<tr style="background: ${bgColor};">`;
                html += `<td style="border: 1px solid #ddd; padding: 6px; text-align: center;">${h.harmonic}P</td>`;
                html += `<td style="border: 1px solid #ddd; padding: 6px; text-align: right;">${h.amplitude.toFixed(3)}</td>`;
                html += `<td style="border: 1px solid #ddd; padding: 6px; text-align: right;">${h.phase.toFixed(1)}¬∞</td>`;
                html += '</tr>';
            });
            html += '</tbody></table>';
            
            html += '<h4>Blade 1 Yawing Moment</h4>';
            html += '<table style="border-collapse: collapse; font-size: 0.9em; margin-bottom: 15px;">';
            html += '<thead><tr style="background: #667eea; color: white;">';
            html += '<th style="border: 1px solid #ddd; padding: 6px;">Harmonic</th>';
            html += '<th style="border: 1px solid #ddd; padding: 6px;">Amplitude</th>';
            html += '<th style="border: 1px solid #ddd; padding: 6px;">Phase (deg)</th>';
            html += '</tr></thead><tbody>';
            blade1MomentYFourier.forEach((h, idx) => {
                const bgColor = idx % 2 === 0 ? '#f9f9f9' : '#ffffff';
                html += `<tr style="background: ${bgColor};">`;
                html += `<td style="border: 1px solid #ddd; padding: 6px; text-align: center;">${h.harmonic}P</td>`;
                html += `<td style="border: 1px solid #ddd; padding: 6px; text-align: right;">${h.amplitude.toFixed(3)}</td>`;
                html += `<td style="border: 1px solid #ddd; padding: 6px; text-align: right;">${h.phase.toFixed(1)}¬∞</td>`;
                html += '</tr>';
            });
            html += '</tbody></table>';
            
            html += '<h4>Blade 1 Nodding Moment</h4>';
            html += '<table style="border-collapse: collapse; font-size: 0.9em; margin-bottom: 15px;">';
            html += '<thead><tr style="background: #667eea; color: white;">';
            html += '<th style="border: 1px solid #ddd; padding: 6px;">Harmonic</th>';
            html += '<th style="border: 1px solid #ddd; padding: 6px;">Amplitude</th>';
            html += '<th style="border: 1px solid #ddd; padding: 6px;">Phase (deg)</th>';
            html += '</tr></thead><tbody>';
            blade1MomentZFourier.forEach((h, idx) => {
                const bgColor = idx % 2 === 0 ? '#f9f9f9' : '#ffffff';
                html += `<tr style="background: ${bgColor};">`;
                html += `<td style="border: 1px solid #ddd; padding: 6px; text-align: center;">${h.harmonic}P</td>`;
                html += `<td style="border: 1px solid #ddd; padding: 6px; text-align: right;">${h.amplitude.toFixed(3)}</td>`;
                html += `<td style="border: 1px solid #ddd; padding: 6px; text-align: right;">${h.phase.toFixed(1)}¬∞</td>`;
                html += '</tr>';
            });
            html += '</tbody></table>';
            
            output.innerHTML = html;
        }
        
        // Update spanwise loading chart with blade 1 data
        function updateSpanwiseChart() {
            if (!blades || blades.length === 0) return;
            if (!spanwiseChart) return;
            
            const blade = blades[0]; // Blade 1
            if (!blade.segments || blade.segments.length === 0) return;
            
            // Get selected force type
            const forceType = document.getElementById('spanwise-force-type').value;
            
            // Collect data points from already-calculated force values
            const dataPoints = [];
            let minForce = Infinity;
            let maxForce = -Infinity;
            
            blade.segments.forEach(segment => {
                const r = segment.userData.radius || 0;
                let force;
                
                // Select the appropriate force based on dropdown
                if (forceType === 'thrust') {
                    force = segment.userData.thrust || 0;
                } else if (forceType === 'tangential') {
                    force = segment.userData.tangentialForce || 0;
                } else if (forceType === 'resultant') {
                    force = segment.userData.resultantForce || 0;
                } else if (forceType === 'aoa') {
                    force = segment.userData.aoa || 0;
                } else if (forceType === 'velocity') {
                    force = segment.userData.totalVelocity || 0;
                } else if (forceType === 'cl') {
                    force = segment.userData.Cl || 0;
                } else if (forceType === 'cd') {
                    force = segment.userData.Cd || 0;
                }
                
                // Calculate spanwise position as percentage
                const spanPercent = (r / turbineParams.bladeRadius) * 100;
                
                dataPoints.push({ x: spanPercent, y: force });
                
                // Track min/max for dynamic scaling
                if (force < minForce) minForce = force;
                if (force > maxForce) maxForce = force;
            });
            
            // Update chart data
            spanwiseChart.data.datasets[0].data = dataPoints;
            
            // Dynamically adjust y-axis based on current data
            // Add 10% margin for better visualization
            const margin = (maxForce - minForce) * 0.1;
            spanwiseChart.options.scales.y.min = minForce - margin;
            spanwiseChart.options.scales.y.max = maxForce + margin;
            
            spanwiseChart.update('none');
        }
        
        // Calculate appropriate y-axis range for spanwise chart based on actual loads
        function calculateSpanwiseYAxisRange() {
            let minThrust = Infinity;
            let maxThrust = -Infinity;
            
            // Sample various azimuth positions to find full range
            const originalRotation = rotorGroup.rotation.x;
            const sampleAzimuths = [0, 45, 90, 135, 180, 225, 270, 315];
            
            sampleAzimuths.forEach(azimuthDeg => {
                const azimuthRad = azimuthDeg * Math.PI / 180;
                rotorGroup.rotation.x = azimuthRad;
                
                // Calculate loads at this azimuth
                updateBladeLoads();
                
                // Check all segments
                if (blades.length > 0 && blades[0].segments) {
                    blades[0].segments.forEach(segment => {
                        const thrust = segment.userData.thrust || 0;
                        if (thrust < minThrust) minThrust = thrust;
                        if (thrust > maxThrust) maxThrust = thrust;
                    });
                }
            });
            
            // Restore original rotation
            rotorGroup.rotation.x = originalRotation;
            updateBladeLoads();
            
            // Add 10% padding
            const range = maxThrust - minThrust;
            const padding = range * 0.1;
            minThrust -= padding;
            maxThrust += padding;
            
            // Update chart y-axis
            if (spanwiseChart) {
                spanwiseChart.options.scales.y.min = minThrust;
                spanwiseChart.options.scales.y.max = maxThrust;
            spanwiseChart.update('none');
            }
        }
        
        // Update section diagram with velocity vectors
        function updateSectionDiagram() {
            if (!blades || blades.length === 0 || !sectionChart) return;
            
            const blade = blades[0];
            if (!blade.segments || blade.segments.length === 0) return;
            
            // Get current radial station from section's own slider
            const stationPercent = parseFloat(document.getElementById('section-radial-station').value);
            const r = turbineParams.bladeRadius * stationPercent / 100;
            
            const segmentIndex = Math.floor((stationPercent - 10) / 85 * blade.segments.length);
            const segment = blade.segments[Math.max(0, Math.min(segmentIndex, blade.segments.length - 1))];
            
            if (!segment) return;
            
            const chord = segment.userData.chord || 1;
            const twist = segment.userData.twist || 0;
            const azimuth = (-rotorGroup.rotation.x * 180 / Math.PI) % 360;
            const azimuthRad = -rotorGroup.rotation.x;  // Use radians directly, negated for correct direction
            
            // Get actual pitch angle (convert from 0=disc, 90=feathered convention)
            // For 3D visualization, we need to convert, but for aerodynamics, use bladePitch directly
            const actualPitchAngle = turbineParams.bladePitch; // Use slider value directly for aerodynamics
            const totalBladeAngle = twist + actualPitchAngle; // Total rotation of blade for aerodynamics
            const angleRad = -totalBladeAngle * Math.PI / 180; // Negative for correct direction
            
            // Calculate velocity components
            const V = turbineParams.windSpeed;
            const inflowRadians = turbineParams.inflowAngle * Math.PI / 180;
            const yawRadians = turbineParams.yawAngle * Math.PI / 180;
            
            const V_x = V * Math.sin(yawRadians);
            const V_y = V * Math.sin(inflowRadians) * Math.cos(yawRadians);
            const V_z = V * Math.cos(inflowRadians) * Math.cos(yawRadians);
            
            const omega = turbineParams.shaftSpeed * 2 * Math.PI / 60;
            const U = omega * r;
            
            const V_inplane_tangential = V_x * Math.cos(azimuthRad) - V_y * Math.sin(azimuthRad);
            const V_normal = V_z;
            
            const Vt = U + V_inplane_tangential; // Tangential velocity (rotational + wind)
            const Vn = V_normal * (1 - 0.3); // Normal velocity (axial wind) with induction factor
            
            // Generate NREL-style airfoil profile (rotated by twist + pitch)
            // Use same thickness distribution and region-specific shapes as 3D blade model
            const spanFraction = stationPercent / 100;
            const thickness_ratio = 0.40 * (1 - spanFraction) + 0.18 * spanFraction; // NREL-style: 40% at root, 18% at tip
            
            // Region-specific airfoil characteristics (matching 3D blade creation)
            let camberAmount, leadingEdgeRadius;
            
            if (spanFraction < 0.3) {
                // Root region - thick structural airfoil
                camberAmount = 0.015;  // Less camber
                leadingEdgeRadius = 1.2; // Blunter leading edge
            } else if (spanFraction < 0.7) {
                // Mid-span region - primary aerodynamic airfoil
                camberAmount = 0.025;  // More camber for lift
                leadingEdgeRadius = 1.0; // Standard leading edge
            } else {
                // Tip region - thin high-performance airfoil
                camberAmount = 0.018;  // Moderate camber
                leadingEdgeRadius = 0.8; // Sharper leading edge
            }
            
            // DEBUG MODE: Super extra camber to verify orientation
            if (turbineParams.debugCamber) {
                camberAmount = 0.15;  // 15% camber - super obvious!
            }
            
            const airfoilPoints = [];
            const numPoints = 50;
            
            // Upper surface
            for (let i = 0; i <= numPoints; i++) {
                // Cosine spacing for better leading edge resolution
                const t = i / numPoints;
                const xNorm = (1 - Math.cos(t * Math.PI)) / 2; // Cosine spacing
                // Shift origin to quarter chord: xLocal now goes from -0.25c (LE) to +0.75c (TE)
                const xLocal = (xNorm - 0.25) * chord; // Origin at quarter chord
                
                // NREL-style thickness distribution with region-specific leading edge radius
                const yLocal = 5 * thickness_ratio * chord * leadingEdgeRadius * (
                    0.2969 * Math.sqrt(xNorm) -
                    0.1260 * xNorm -
                    0.3516 * xNorm * xNorm +
                    0.2843 * xNorm * xNorm * xNorm -
                    0.1036 * xNorm * xNorm * xNorm * xNorm
                );
                
                // Add region-specific camber
                const camber = camberAmount * chord * 4 * (xNorm - xNorm * xNorm);
                const yLocal_cambered = yLocal + camber;
                
                // Rotate by total blade angle
                const x = xLocal * Math.cos(angleRad) - yLocal_cambered * Math.sin(angleRad);
                const y = -(xLocal * Math.sin(angleRad) + yLocal_cambered * Math.cos(angleRad)); // Negate y
                airfoilPoints.push({ x: x, y: y });
            }
            
            // Lower surface (reverse order)
            for (let i = numPoints; i >= 0; i--) {
                const t = i / numPoints;
                const xNorm = (1 - Math.cos(t * Math.PI)) / 2; // Cosine spacing
                // Shift origin to quarter chord: xLocal now goes from -0.25c (LE) to +0.75c (TE)
                const xLocal = (xNorm - 0.25) * chord; // Origin at quarter chord
                
                // NREL-style thickness distribution with region-specific leading edge radius
                const yLocal = -5 * thickness_ratio * chord * leadingEdgeRadius * (
                    0.2969 * Math.sqrt(xNorm) -
                    0.1260 * xNorm -
                    0.3516 * xNorm * xNorm +
                    0.2843 * xNorm * xNorm * xNorm -
                    0.1036 * xNorm * xNorm * xNorm * xNorm
                );
                
                // Add region-specific camber
                const camber = camberAmount * chord * 4 * (xNorm - xNorm * xNorm);
                const yLocal_cambered = yLocal + camber;
                
                // Rotate by total blade angle
                const x = xLocal * Math.cos(angleRad) - yLocal_cambered * Math.sin(angleRad);
                const y = -(xLocal * Math.sin(angleRad) + yLocal_cambered * Math.cos(angleRad)); // Negate y
                airfoilPoints.push({ x: x, y: y });
            }
            
            // Velocity vector scale
            const vectorScale = 0.15; // Scale factor for visibility
            
            // V_tangential vector (vertical, from bottom - tail grows down, head at airfoil)
            const vt_scaled = Vt * vectorScale;
            const vtVector = [
                { x: 0, y: -vt_scaled }, // Tail starts below based on velocity
                { x: 0, y: 0 } // Head at airfoil (fixed)
            ];
            
            // V_normal vector (horizontal, from left - tail grows left, head at airfoil)
            const vn_scaled = Vn * vectorScale;
            const vnVector = [
                { x: -vn_scaled, y: 0 }, // Tail starts left based on velocity
                { x: 0, y: 0 } // Head at airfoil (fixed)
            ];
            
            // V_resultant vector (diagonal - tail grows, head at airfoil)
            const vResultantVector = [
                { x: -vn_scaled, y: -vt_scaled }, // Tail position based on both velocities
                { x: 0, y: 0 } // Head at airfoil (fixed)
            ];
            
            // Calculate the angle of the resultant velocity vector from its coordinates
            // Vector goes from tail (-vn_scaled, -vt_scaled) to head (0, 0)
            // So the direction vector is (vn_scaled, vt_scaled)
            // phi is calculated as atan2(Vn, Vt), so we should use atan2(vn_scaled, vt_scaled)
            const resultant_angle_from_coords = Math.atan2(vn_scaled, vt_scaled);
            
            // Calculate phi from the local Vn and Vt (this is the flow angle)
            const phi = Math.atan2(Vn, Vt);
            
            // Blade angle (geometric): angle from V_tangential to chord line
            const bladeAngleGeometric = 90 - totalBladeAngle;
            
            // Calculate angle of attack: AoA = phi - blade angle (geometric)
            const aoa = (phi * 180 / Math.PI) - bladeAngleGeometric;
            
            // Calculate lift and drag coefficients for this section
            const Cl = getLiftCoefficient(aoa, thickness_ratio);
            const Cd = getDragCoefficient(aoa, thickness_ratio, Cl);
            
            // Get aerodynamic forces from segment userData (already calculated in updateBladeLoads)
            const L = segment.userData.L || 0; // Lift
            const D = segment.userData.D || 0; // Drag
            const thrust = segment.userData.thrust || 0; // Thrust (axial force)
            
            // Force vector scale (forces are much larger than velocities)
            const forceScale = 0.005 * turbineParams.forceScale; // Scale factor for visibility (0.005 base * user scale)
            
            // Lift: perpendicular to incoming flow, points "up" from airfoil
            // Flow comes from direction (Vn, Vt), lift is perpendicular (rotated 90¬∞ CW)
            // Perpendicular to (Vn, Vt) rotated 90¬∞ CW is (Vt, -Vn)
            const V_mag = Math.sqrt(Vn*Vn + Vt*Vt);
            const lift_x = L * (Vt / V_mag) * forceScale;  // Perpendicular to flow
            const lift_y = -L * (Vn / V_mag) * forceScale;   // Perpendicular to flow
            
            // Origin is now at quarter chord, so forces start at (0, 0)
            const liftVector = [
                { x: 0, y: 0 }, // Tail at origin (quarter chord)
                { x: lift_x, y: lift_y } // Head points perpendicular to flow
            ];
            
            // Drag: parallel to velocity (pointing away from blade, in direction of flow)
            const drag_x = D * (Vn / V_mag) * forceScale;
            const drag_y = D * (Vt / V_mag) * forceScale;
            const dragVector = [
                { x: 0, y: 0 }, // Tail at origin (quarter chord)
                { x: drag_x, y: drag_y } // Head points in flow direction
            ];
            
            // Resultant force vector: vector sum of lift and drag
            const resultant_x = lift_x + drag_x;
            const resultant_y = lift_y + drag_y;
            const resultantForceVector = [
                { x: 0, y: 0 }, // Tail at origin (quarter chord)
                { x: resultant_x, y: resultant_y } // Head is sum of L and D
            ];
            
            // Thrust vector: axial force (thrust = L*cos(phi) + D*sin(phi))
            const thrustVector = [
                { x: 0, y: 0 }, // Tail at origin (quarter chord)
                { x: thrust * forceScale, y: 0 } // Head points in axial direction (normal to disc)
            ];
            
            // Tangential force vector: F_tangent = L*sin(phi) - D*cos(phi)
            const F_tangent = L * Math.sin(phi) - D * Math.cos(phi);
            const tangentVector = [
                { x: 0, y: 0 }, // Tail at origin (quarter chord)
                { x: 0, y: -F_tangent * forceScale } // Head points in tangential direction
            ];
            
            // Chord line (dashed black line through airfoil at blade angle)
            // Origin at quarter chord: LE at -0.25c, TE at +0.75c
            const chordLength = chord;
            const chordLine = [
                { x: -0.25 * chordLength * Math.cos(angleRad), y: -(-0.25 * chordLength * Math.sin(angleRad)) },
                { x: 0.75 * chordLength * Math.cos(angleRad), y: -(0.75 * chordLength * Math.sin(angleRad)) }
            ];
            
            // Phi (œÜ) angle arc - angle between V_tangential and V_resultant
            // Both vectors point TO the origin from their tails
            // V_tangential direction: straight up (from 0, -vt to 0, 0)
            // V_resultant direction: from (-vn, -vt) to (0, 0)
            const phiAngleArc = [];
            const arcRadius = 0.5;
            const numArcPoints = 20;
            
            // Starting angle: V_tangential points straight up (90¬∞ in chart coords)
            const vtAngle = Math.PI / 2;
            
            // Ending angle: V_resultant direction
            // Direction vector of V_resultant: (vn_scaled, vt_scaled)
            const vresAngle = Math.atan2(vt_scaled, vn_scaled);
            
            for (let i = 0; i <= numArcPoints; i++) {
                // Sweep from V_tangential to V_resultant
                const angle = vtAngle - i / numArcPoints * (vtAngle - vresAngle);
                const x = arcRadius * Math.cos(angle);
                const y = arcRadius * Math.sin(angle);
                phiAngleArc.push({ x: -x, y: -y }); // Negate both x and y for chart coordinates
            }
            
            // AoA angle arc (from V_resultant to chord line)
            const aoaAngleArc = [];
            const aoaArcRadius = 0.7;
            
            // V_resultant angle (same as calculated for phi arc)
            const vresAngleForAoA = Math.atan2(vt_scaled, vn_scaled);
            
            // Chord line is at angle = -angleRad (because of the Y negation in drawing)
            const chordAngle = -angleRad;
            
            for (let i = 0; i <= numArcPoints; i++) {
                // Arc from resultant velocity to chord line
                const angle = vresAngleForAoA - i / numArcPoints * (vresAngleForAoA - chordAngle);
                const x = aoaArcRadius * Math.cos(angle);
                const y = aoaArcRadius * Math.sin(angle);
                aoaAngleArc.push({ x: -x, y: -y }); // Negate both x and y for chart coordinates
            }
            
            // Pitch angle arc (from V_tangential to chord line)
            const pitchAngleArc = [];
            const pitchArcRadius = 0.9;
            
            // V_tangential angle: points straight up (90¬∞ in chart coords)
            const vtAngleForPitch = Math.PI / 2;
            
            // Chord line is at angle = -angleRad (because of the Y negation in drawing)
            const chordAngleForPitch = -angleRad;
            
            for (let i = 0; i <= numArcPoints; i++) {
                // Arc from V_tangential to chord line
                const angle = vtAngleForPitch - i / numArcPoints * (vtAngleForPitch - chordAngleForPitch);
                const x = pitchArcRadius * Math.cos(angle);
                const y = pitchArcRadius * Math.sin(angle);
                pitchAngleArc.push({ x: -x, y: -y }); // Negate both x and y for chart coordinates
            }
            
            // Extension lines for angle visualization
            // Chord line extension for AoA arc (extends from chord endpoints to arc radius)
            const chordExtension = [];
            const extensionLength = 1.5; // Extend beyond the arc
            const chordExtStart = { 
                x: extensionLength * Math.cos(angleRad), 
                y: -(extensionLength * Math.sin(angleRad))
            };
            const chordExtEnd = { 
                x: -extensionLength * Math.cos(angleRad), 
                y: -(-extensionLength * Math.sin(angleRad))
            };
            chordExtension.push(chordExtStart, chordExtEnd);
            
            // V‚Çú extension line (vertical line extended from origin)
            const vtExtension = [];
            const vtExtLength = 1.5;
            vtExtension.push({ x: 0, y: -vtExtLength }, { x: 0, y: vtExtLength });
            
            // V·µ£ extension line (along resultant velocity direction)
            const vrExtension = [];
            const vrExtLength = 1.5;
            const vrAngle = Math.atan2(vt_scaled, vn_scaled);
            vrExtension.push(
                { x: 0, y: 0 },
                { x: -vrExtLength * Math.cos(vrAngle), y: -vrExtLength * Math.sin(vrAngle) }
            );
            
            // Update chart datasets
            sectionChart.data.datasets[0].data = airfoilPoints; // Airfoil
            sectionChart.data.datasets[1].data = vtVector; // V_tangential
            sectionChart.data.datasets[2].data = vnVector; // V_normal
            sectionChart.data.datasets[3].data = vResultantVector; // V_resultant
            sectionChart.data.datasets[4].data = liftVector; // Lift
            sectionChart.data.datasets[5].data = dragVector; // Drag
            sectionChart.data.datasets[6].data = resultantForceVector; // Resultant Force
            sectionChart.data.datasets[7].data = thrustVector; // Thrust
            sectionChart.data.datasets[8].data = tangentVector; // Tangential Force
            sectionChart.data.datasets[9].data = chordLine; // Chord Line
            sectionChart.data.datasets[10].data = phiAngleArc; // Phi Angle
            sectionChart.data.datasets[11].data = aoaAngleArc; // AoA Angle
            sectionChart.data.datasets[12].data = pitchAngleArc; // Pitch Angle
            sectionChart.data.datasets[13].data = chordExtension; // Chord Extension
            sectionChart.data.datasets[14].data = vtExtension; // V‚Çú Extension
            sectionChart.data.datasets[15].data = vrExtension; // V·µ£ Extension
            
            // Update angle values for tooltips
            sectionAngleValues.phi = phi * 180 / Math.PI;
            sectionAngleValues.alpha = aoa;
            sectionAngleValues.theta = bladeAngleGeometric;
            sectionAngleValues.Vt = Vt;
            sectionAngleValues.Vn = Vn;
            sectionAngleValues.VR = V_mag;
            sectionAngleValues.L = L;
            sectionAngleValues.D = D;
            sectionAngleValues.thrust = thrust;
            sectionAngleValues.tangent = F_tangent;
            
            // Update angle displays
            document.getElementById('pitch-display').textContent = bladeAngleGeometric.toFixed(2);
            document.getElementById('phi-display').textContent = (phi * 180 / Math.PI).toFixed(2);
            document.getElementById('aoa-display').textContent = aoa.toFixed(2);
            document.getElementById('cl-display').textContent = Cl.toFixed(3);
            document.getElementById('cd-display').textContent = Cd.toFixed(4);
            
            sectionChart.update('none');
            
            // Update the 3D section plane if it's visible
            if (sectionPlane && document.getElementById('show-section-plane').checked) {
                createSectionPlane();
            }
        }
        
        // Perform DFT analysis on a signal
        function analyzeFourier(signal, maxHarmonic = 4) {
            const N = signal.length;
            const results = [];
            
            for (let k = 0; k <= maxHarmonic; k++) {
                let real = 0;
                let imag = 0;
                
                for (let n = 0; n < N; n++) {
                    const angle = (2 * Math.PI * k * n) / N;
                    real += signal[n] * Math.cos(angle);
                    imag += signal[n] * Math.sin(angle);
                }
                
                real /= N;
                imag /= N;
                
                // For k > 0, multiply by 2 to get amplitude (since we only look at positive frequencies)
                const amplitude = k === 0 ? real : 2 * Math.sqrt(real * real + imag * imag);
                const phase = Math.atan2(imag, real) * 180 / Math.PI;
                
                results.push({
                    harmonic: k,
                    amplitude: amplitude,
                    phase: phase,
                    real: real,
                    imag: imag
                });
            }
            
            return results;
        }
        
        // Helper to describe blade position
        function getPositionDescription(azimuthDeg) {
            if (azimuthDeg < 45 || azimuthDeg >= 315) return '‚Üë Top';
            if (azimuthDeg >= 45 && azimuthDeg < 135) return '‚Üí Adv';
            if (azimuthDeg >= 135 && azimuthDeg < 225) return '‚Üì Bot';
            return '‚Üê Ret';
        }
        
        // Helper function to calculate thrust at a given azimuth
        function calculateThrustAtAzimuth(azimuth, r, chord, omega, windSpeedAxial, windSpeedTangential, inflowRadians) {
            // Blade twist distribution (optimal for constant AoA)
            // Varies inversely with radius to maintain constant flow angle
            const r_norm = (r - turbineParams.hubRadius) / (turbineParams.bladeRadius - turbineParams.hubRadius);
            const r_root = turbineParams.hubRadius;
            const r_tip = turbineParams.bladeRadius;
            const twist_weight = (r_tip / r - 1) / (r_tip / r_root - 1);
            const twist = turbineParams.twistRoot * twist_weight + turbineParams.twistTip * (1 - twist_weight);
            
            // Velocities in rotor disc coordinates
            // Use proper coordinate transformation
            const V = turbineParams.windSpeed;
            const alpha = inflowRadians;
            const beta = turbineParams.yawAngle * Math.PI / 180;
            
            const V_x = V * Math.sin(beta);
            const V_y = V * Math.sin(alpha) * Math.cos(beta);
            const V_z = V * Math.cos(alpha) * Math.cos(beta);
            
            // In-plane velocity component at blade azimuth (perpendicular to radius)
            const V_inplane_tangential = V_x * Math.cos(azimuth) - V_y * Math.sin(azimuth);
            
            // Tangential velocity (rotation + in-plane wind)
            const Vt = omega * r + V_inplane_tangential;
            
            // Normal velocity (axial wind + induction)
            const Vn = V_z * (1 - 0.3); // With induction factor - should be positive
            
            // Flow angle and angle of attack
            const phi = Math.atan2(Vn, Vt);
            // Use bladePitch directly for aerodynamics (slider value is the aerodynamic angle)
            const aeroPitchAngle = turbineParams.bladePitch;
            const totalBladeAngle = twist + aeroPitchAngle;
            const bladeAngleGeometric = 90 - totalBladeAngle;
            // AoA = phi - blade angle (geometric)
            const aoa = (phi * 180 / Math.PI) - bladeAngleGeometric;
            
            // Dynamic pressure
            const V_total = Math.sqrt(Vt * Vt + Vn * Vn);
            const q = 0.5 * 1.225 * V_total * V_total * chord * (turbineParams.bladeRadius / 100);
            
            // Realistic aerodynamic model with stall
            // Get thickness ratio for this span location
            const spanFrac = (r - turbineParams.hubRadius) / (turbineParams.bladeRadius - turbineParams.hubRadius);
            const thickness_ratio = 0.40 * (1 - spanFrac) + 0.18 * spanFrac;
            
            // Get lift and drag coefficients
            const Cl = getLiftCoefficient(aoa, thickness_ratio);
            const Cd = getDragCoefficient(aoa, thickness_ratio, Cl);
            
            const L = q * Cl;
            const D = q * Cd;
            
            // Thrust (axial force)
            const thrust = L * Math.cos(phi) + D * Math.sin(phi);
            return thrust;
        }
        
        // Make panels draggable (only by their headers)
        function makeDraggable(element, handleSelector) {
            let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
            
            // Get the header element if selector provided, otherwise use the whole element
            const handle = handleSelector ? element.querySelector(handleSelector) : element;
            
            if (handle) {
                handle.onmousedown = dragMouseDown;
                handle.style.cursor = 'move';
            }
            
            function dragMouseDown(e) {
                // Don't drag if clicking on a button
                if (e.target.tagName === 'BUTTON') {
                    return;
                }
                e.preventDefault();
                pos3 = e.clientX;
                pos4 = e.clientY;
                document.onmouseup = closeDragElement;
                document.onmousemove = elementDrag;
                // Clear bottom positioning to prevent height stretching when both top and bottom are set
                element.style.bottom = '';
            }
            
            function elementDrag(e) {
                e.preventDefault();
                pos1 = pos3 - e.clientX;
                pos2 = pos4 - e.clientY;
                pos3 = e.clientX;
                pos4 = e.clientY;
                element.style.top = (element.offsetTop - pos2) + "px";
                element.style.left = (element.offsetLeft - pos1) + "px";
            }
            
            function closeDragElement() {
                document.onmouseup = null;
                document.onmousemove = null;
            }
        }
        
        makeDraggable(document.getElementById('controls-panel'), '.panel-header');
        makeDraggable(document.getElementById('plot-panel'), '.plot-header');
        makeDraggable(document.getElementById('spanwise-panel'), '.plot-header');
        
        // Minimize controls panel
        document.getElementById('minimize-btn').addEventListener('click', () => {
            const panel = document.getElementById('controls-panel');
            const btn = document.getElementById('minimize-btn');
            panel.classList.toggle('minimized');
            btn.textContent = panel.classList.contains('minimized') ? '+' : '‚àí';
        });
        
        // Minimize plot panel
        document.getElementById('minimize-plot-btn').addEventListener('click', () => {
            const panel = document.getElementById('plot-panel');
            const btn = document.getElementById('minimize-plot-btn');
            panel.classList.toggle('minimized');
            
            if (panel.classList.contains('minimized')) {
                // Store current dimensions before minimizing
                panel.dataset.savedWidth = panel.style.width || '800px';
                panel.dataset.savedHeight = panel.style.height || '600px';
                // Force minimal height when minimized
                panel.style.width = 'auto';
                panel.style.height = 'auto';
                panel.style.minHeight = '0';
                panel.style.minWidth = '0';
                panel.style.bottom = ''; // Clear bottom anchor to prevent stretching
                btn.textContent = '+';
            } else {
                // Restore previous dimensions when expanding
                panel.style.width = panel.dataset.savedWidth || '800px';
                panel.style.height = panel.dataset.savedHeight || '600px';
                panel.style.minHeight = '';
                panel.style.minWidth = '';
                btn.textContent = '‚àí';
            }
        });
        
        // Tab switching for traces
        document.querySelectorAll('.trace-tab-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const tabName = btn.getAttribute('data-tab');
                
                // Update button states
                document.querySelectorAll('.trace-tab-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                
                // Update tab content visibility
                document.querySelectorAll('.trace-tab-content').forEach(content => {
                    content.classList.remove('active');
                });
                document.getElementById(tabName + '-tab').classList.add('active');
                
                // Force chart resize when switching tabs
                setTimeout(() => {
                    if (tabName === 'thrust' && typeof liftChart !== 'undefined') {
                        liftChart.resize();
                    } else if (tabName === 'moment-y' && typeof momentYChart !== 'undefined') {
                        momentYChart.resize();
                    } else if (tabName === 'moment-z' && typeof momentZChart !== 'undefined') {
                        momentZChart.resize();
                    }
                }, 100);
            });
        });
        
        // Spanwise panel tab switching
        document.querySelectorAll('.spanwise-tab-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const tabName = btn.getAttribute('data-tab');
                
                // Update button states
                document.querySelectorAll('.spanwise-tab-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                
                // Update tab content visibility
                document.querySelectorAll('.spanwise-tab-content').forEach(content => {
                    content.classList.remove('active');
                });
                document.getElementById(tabName + '-tab').classList.add('active');
                
                // Update tab when switching
                setTimeout(() => {
                    if (tabName === 'section') {
                        updateSectionDiagram();
                    }
                }, 100);
            });
        });
        
        // Spanwise panel minimize/maximize
        document.getElementById('minimize-spanwise-btn').addEventListener('click', function() {
            const panel = document.getElementById('spanwise-panel');
            const btn = this;
            
            if (panel.classList.contains('minimized')) {
                // Expand - restore previous dimensions
                panel.classList.remove('minimized');
                panel.style.width = panel.dataset.savedWidth || '600px';
                panel.style.height = panel.dataset.savedHeight || '700px';
                btn.textContent = '‚àí';
            } else {
                // Minimize - store and clear inline styles
                panel.dataset.savedWidth = panel.style.width || '600px';
                panel.dataset.savedHeight = panel.style.height || '700px';
                panel.style.width = '';
                panel.style.height = '';
                panel.classList.add('minimized');
                btn.textContent = '+';
            }
        });
        
        // Window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            if (composer){
                composer.setSize(window.innerWidth, window.innerHeight);
                if (fxaaPass){
                    fxaaPass.material.uniforms['resolution'].value.set(1 / window.innerWidth, 1 / window.innerHeight);
                }
            }
        });
        
        // Add global event listeners to all control inputs to save state when changed
        const allControlInputs = document.querySelectorAll('#control-panel input[type="range"], #control-panel input[type="checkbox"], #control-panel select');
        allControlInputs.forEach(input => {
            input.addEventListener('input', () => debouncedSaveState());
            input.addEventListener('change', () => debouncedSaveState());
        });
        
        // URL State Management - save/restore parameters
        function saveStateToURL() {
            const params = new URLSearchParams();
            
            // Save main parameters
            params.set('windSpeed', turbineParams.windSpeed);
            params.set('shaftSpeed', turbineParams.shaftSpeed);
            params.set('bladePitch', turbineParams.bladePitch);
            params.set('twistRoot', turbineParams.twistRoot);
            params.set('twistTip', turbineParams.twistTip);
            params.set('numBlades', turbineParams.numBlades);
            params.set('yawAngle', turbineParams.yawAngle);
            params.set('inflowAngle', turbineParams.inflowAngle);
            params.set('radialStation', turbineParams.radialStation);
            params.set('angularResolution', turbineParams.angularResolution);
            params.set('vectorScale', turbineParams.vectorScale);
            params.set('vectorMode', turbineParams.vectorMode);
            params.set('manualRotation', turbineParams.manualRotation);
            params.set('generatorTorque', turbineParams.generatorTorque);
            params.set('rotorInertia', turbineParams.rotorInertia);
            
            // Save boolean flags
            if (turbineParams.showVectors) params.set('showVectors', '1');
            if (turbineParams.showHeatmap) params.set('showHeatmap', '1');
            if (turbineParams.debugCamber) params.set('debugCamber', '1');
            if (turbineParams.showWindVector) params.set('showWindVector', '1');
            if (turbineParams.paused) params.set('paused', '1');
            if (turbineParams.dynamicSpeed) params.set('dynamicSpeed', '1');
            if (turbineParams.windFarmMode) params.set('windFarmMode', '1');
            if (turbineParams.removeMean) params.set('removeMean', '1');
            if (turbineParams.simpleAero) params.set('simpleAero', '1');
            if (turbineParams.debugSinusoid) params.set('debugSinusoid', '1');
            
            // Update URL without reloading
            const newURL = window.location.pathname + '?' + params.toString();
            window.history.replaceState({}, '', newURL);
        }
        
        function loadStateFromURL() {
            const params = new URLSearchParams(window.location.search);
            
            // Load numeric parameters
            if (params.has('windSpeed')) {
                turbineParams.windSpeed = parseFloat(params.get('windSpeed'));
                document.getElementById('wind-speed').value = turbineParams.windSpeed;
                document.getElementById('wind-speed-value').textContent = turbineParams.windSpeed.toFixed(1);
            }
            if (params.has('shaftSpeed')) {
                turbineParams.shaftSpeed = parseFloat(params.get('shaftSpeed'));
                document.getElementById('shaft-speed').value = turbineParams.shaftSpeed;
                document.getElementById('shaft-speed-value').textContent = turbineParams.shaftSpeed.toFixed(1);
                turbineParams.angularVelocity = turbineParams.shaftSpeed * 2 * Math.PI / 60;
            }
            if (params.has('bladePitch')) {
                turbineParams.bladePitch = parseFloat(params.get('bladePitch'));
                document.getElementById('blade-pitch').value = turbineParams.bladePitch;
                document.getElementById('blade-pitch-value').textContent = turbineParams.bladePitch.toFixed(1);
            }
            if (params.has('twistRoot')) {
                turbineParams.twistRoot = parseFloat(params.get('twistRoot'));
            }
            if (params.has('twistTip')) {
                turbineParams.twistTip = parseFloat(params.get('twistTip'));
            }
            if (params.has('numBlades')) {
                turbineParams.numBlades = parseInt(params.get('numBlades'));
                document.getElementById('num-blades').value = turbineParams.numBlades;
                document.getElementById('num-blades-value').textContent = turbineParams.numBlades;
            }
            if (params.has('yawAngle')) {
                turbineParams.yawAngle = parseFloat(params.get('yawAngle'));
                document.getElementById('yaw').value = turbineParams.yawAngle;
                document.getElementById('yaw-value').textContent = turbineParams.yawAngle.toFixed(1);
            }
            if (params.has('inflowAngle')) {
                turbineParams.inflowAngle = parseFloat(params.get('inflowAngle'));
                document.getElementById('inflow').value = turbineParams.inflowAngle;
                document.getElementById('inflow-value').textContent = turbineParams.inflowAngle.toFixed(1);
            }
            if (params.has('radialStation')) {
                turbineParams.radialStation = parseFloat(params.get('radialStation'));
                const stationPercent = turbineParams.radialStation * 100;
                document.getElementById('radial-station').value = stationPercent;
                document.getElementById('station-value').textContent = stationPercent.toFixed(0);
            }
            if (params.has('angularResolution')) {
                turbineParams.angularResolution = parseFloat(params.get('angularResolution'));
                document.getElementById('angular-resolution').value = turbineParams.angularResolution;
                document.getElementById('angular-res-value').textContent = turbineParams.angularResolution.toFixed(2);
            }
            if (params.has('vectorScale')) {
                turbineParams.vectorScale = parseFloat(params.get('vectorScale'));
                document.getElementById('vector-scale').value = turbineParams.vectorScale;
                document.getElementById('vector-scale-value').textContent = turbineParams.vectorScale.toFixed(3);
            }
            if (params.has('vectorMode')) {
                turbineParams.vectorMode = params.get('vectorMode');
                document.getElementById('vector-mode').value = turbineParams.vectorMode;
            }
            if (params.has('manualRotation')) {
                turbineParams.manualRotation = parseFloat(params.get('manualRotation'));
                document.getElementById('manual-rotation').value = turbineParams.manualRotation;
                document.getElementById('manual-rotation-value').textContent = turbineParams.manualRotation.toFixed(1);
            }
            if (params.has('generatorTorque')) {
                turbineParams.generatorTorque = parseFloat(params.get('generatorTorque'));
                document.getElementById('generator-torque').value = turbineParams.generatorTorque;
                document.getElementById('gen-torque-value').textContent = turbineParams.generatorTorque.toFixed(0);
            }
            if (params.has('rotorInertia')) {
                turbineParams.rotorInertia = parseFloat(params.get('rotorInertia'));
                document.getElementById('rotor-inertia').value = turbineParams.rotorInertia;
                document.getElementById('rotor-inertia-value').textContent = turbineParams.rotorInertia.toFixed(0);
            }
            
            // Load boolean flags
            if (params.has('showVectors')) {
                turbineParams.showVectors = true;
                document.getElementById('show-vectors').checked = true;
            }
            if (params.has('showHeatmap')) {
                turbineParams.showHeatmap = true;
                document.getElementById('show-heatmap').checked = true;
            }
            if (params.has('debugCamber')) {
                turbineParams.debugCamber = true;
                document.getElementById('debug-camber').checked = true;
            }
            if (params.has('showWindVector')) {
                turbineParams.showWindVector = true;
                document.getElementById('show-wind-vector').checked = true;
            }
            if (params.has('paused')) {
                turbineParams.paused = true;
                document.getElementById('pause-rotation').checked = true;
            }
            if (params.has('dynamicSpeed')) {
                turbineParams.dynamicSpeed = true;
                document.getElementById('dynamic-speed').checked = true;
            }
            if (params.has('windFarmMode')) {
                turbineParams.windFarmMode = true;
                document.getElementById('wind-farm-mode').checked = true;
            }
            if (params.has('removeMean')) {
                turbineParams.removeMean = true;
                document.getElementById('remove-mean').checked = true;
            }
            if (params.has('simpleAero')) {
                turbineParams.simpleAero = true;
                document.getElementById('simple-aero').checked = true;
            }
            if (params.has('debugSinusoid')) {
                turbineParams.debugSinusoid = true;
                document.getElementById('debug-sinusoid').checked = true;
            }
            
            // Rebuild if blade count or camber changed
            if (params.has('numBlades') || params.has('debugCamber')) {
                updateBladeCount();
            }
            
            // Update wind arrow if needed
            if (params.has('windSpeed') || params.has('yawAngle') || params.has('inflowAngle')) {
                createWindVectorArrow();
            }
            
            // Update wind farm if needed
            if (params.has('windFarmMode')) {
                createWindFarm();
            }
        }
        
        // Load state from URL on page load
        loadStateFromURL();
        
        // Debounced save function to avoid excessive URL updates
        let saveTimeout;
        function debouncedSaveState() {
            clearTimeout(saveTimeout);
            saveTimeout = setTimeout(saveStateToURL, 500);
        }
        
        // Animation loop
        let lastFrameTime = 0;
        const targetFrameTime = 1000 / 60; // 60 FPS target
        
        function animate(currentTime) {
            requestAnimationFrame(animate);
            
            // Frame rate limiter - only update if enough time has passed
            if (currentTime - lastFrameTime < targetFrameTime * 0.9) {
                // Still render, just don't update physics
                renderer.render(scene, camera);
                return;
            }
            lastFrameTime = currentTime;
            
            // Increment frame counter
            frameCount++;
            
            // Update rotor dynamics if in d mode
            // dt is time step in seconds (assuming 60 fps target)
            const dt = targetFrameTime / 1000; // Convert ms to seconds
            updateRotorDynamics(dt);
            
            // Update blade loads BEFORE rotating (so loads match current position)
            updateBladeLoads();
            
            // Update blade 1 azimuth display
            if (blades && blades.length > 0) {
                const blade1Azimuth = blades[0].userData.currentAzimuth || 0;
                const blade1AzimuthDeg = ((blade1Azimuth * 180 / Math.PI) % 360 + 360) % 360;
                document.getElementById('blade-azimuth-display').textContent = blade1AzimuthDeg.toFixed(1) + '¬∞';
            }
            
            // Rotate rotor AFTER calculating loads (only if not paused)
            if (!turbineParams.paused) {
                // Apply speed multiplier during fast Fourier collection
                const speedMultiplier = (fourierData.collecting && fourierData.fastMode) ? fourierData.speedMultiplier : 1;
                const deltaRotation = (turbineParams.shaftSpeed * 2 * Math.PI) / (60 * 60) * speedMultiplier; // per frame at 60fps
                rotorGroup.rotation.x -= deltaRotation;  // Negative for counter-clockwise rotation when viewed from front
                
                // Rotate wind farm turbines with speed variation
                additionalTurbines.forEach(turbine => {
                    const rotorGrp = turbine.userData.rotorGroup;
                    const speedMult = turbine.userData.speedMultiplier;
                    if (rotorGrp) {
                        rotorGrp.rotation.x -= deltaRotation * speedMult * speedMultiplier;  // Match main rotor direction
                    }
                });
            }
            
            // Keep sky centered on camera for infinite distance effect
            skyboxMesh.position.copy(camera.position);
            
            // Animate cloud layer
            cloudOffset += 0.0002;
            cloudPlane.material.map.offset.set(cloudOffset, cloudOffset * 0.7);
            cloudPlane.position.x = camera.position.x;
            cloudPlane.position.z = camera.position.z;
            
            controls.update();
            renderer.render(scene, camera);
        }
        
        // Optional cinematic zoom on key 'z'
        function ease(t){ return t<.5 ? 2*t*t : -1+(4-2*t)*t; }
        function cinematicZoom(targetPos, lookAt, duration=1200){
            const start = performance.now();
            const startPos = camera.position.clone();
            const startExp = renderer.toneMappingExposure;
            const startFocus = bokehPass ? bokehPass.materialBokeh.uniforms['focus'].value : PhotoConfig.bokehFocusFar;
            const endFocus = PhotoConfig.bokehFocusNear;
            const endExp = 1.25;

            function step(now){
                const t = Math.min(1, (now-start)/duration), k = ease(t);
                camera.position.lerpVectors(startPos, targetPos, k);
                controls.target.lerp(lookAt, k);
                if (isPhotoMode){
                    renderer.toneMappingExposure = THREE.MathUtils.lerp(startExp, endExp, k);
                    if (bokehPass) bokehPass.materialBokeh.uniforms['focus'].value =
                        THREE.MathUtils.lerp(startFocus, endFocus, k);
                }
                if (t<1) requestAnimationFrame(step);
            }
            requestAnimationFrame(step);
        }
        document.addEventListener('keydown', (e)=>{
            if (e.key==='z' && hub){
                const p = new THREE.Vector3(); hub.getWorldPosition(p);
                cinematicZoom(p.clone().add(new THREE.Vector3(6,2,6)), p);
            }
        });
        
        // Display toggle button
        let displayState = {
            modalsHidden: false,
            savedVisibility: {}
        };
        
        document.getElementById('display-toggle').addEventListener('click', () => {
            const btn = document.getElementById('display-toggle');
            const panels = ['controls-panel', 'plot-panel', 'spanwise-panel'];
            
            if (!displayState.modalsHidden) {
                // Hide all modals
                panels.forEach(id => {
                    const panel = document.getElementById(id);
                    displayState.savedVisibility[id] = panel.style.display || 'block';
                    panel.style.display = 'none';
                });
                btn.textContent = 'üì∫ Show Displays';
                displayState.modalsHidden = true;
            } else {
                // Restore modals
                panels.forEach(id => {
                    const panel = document.getElementById(id);
                    panel.style.display = displayState.savedVisibility[id] || 'block';
                });
                btn.textContent = 'üì∫ Hide Displays';
                displayState.modalsHidden = false;
            }
        });
        
        animate();
    </script>

</body></html>
